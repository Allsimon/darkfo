<html>
<head>
<title>heart.js test</title>
<script src="heart.js"></script>
<script src="jquery-1.11.1.min.js"></script>
<script>
var matrix = null
var size = 6
var tile_width = 80
var tile_height = 36
var images = {}
var cameraX = 3375
var cameraY = 105

// tile grid geometry info
var transX = 48, transY = 24
var xdx = transX
var ydy = transY
var xdy = ydy - tile_height
var ydx = tile_width - xdx

function tileToScreen(x, y) {
	var sx = x * xdx + y * ydx + 0
	var sy = x * xdy + y * ydy + 0
	return {x: sx, y: sy}
}

// hex grid geometry info
var hexTileW = 32
var hexTileH = 16
var hexTransX = 16
var hexTransY = 12
var _hexOffsetX = 32
var _hexOffsetY = 10
var hexOffsetX = 0
var hexOffsetY = 0

function hexToScreen(x, y) {
	var dx = hexTransX, dy = hexTransY

	var sx = hexOffsetX - (x*hexTileW - (x/2)*dx - y * hexTileH)
	var sy = hexOffsetY + (x/2)*dy + y*dy

	return {x: sx, y: sy}
}

function hexFromScreen(x, y) {
	var mx = (x - hexOffsetX) / -hexTransX
	var my = (y - hexOffsetY) / hexTransY

	var hexX = Math.floor((mx + my + 1) / 2)
	var hexY = Math.floor(Math.floor(my) - hexX/2)

	return {x: hexX, y: hexY}
/*
	Point HexGeometry::fromScreen(const Point& pos) const {

		// FIXME: hit testing is not pixel-perfect; hexs are just being
		// approximated by boxes. Even accounting for that, things still
		// seem to be a bit off. Still, this seems much better than before.
		// -jwt

		float mouse_x = static_cast<float>(pos.x - m_offset.x) / (-m_transform.x);
		float mouse_y = static_cast<float>(pos.y - m_offset.y) / m_transform.y;

		Point hex;

		// x coordinates seem to be off by half a hex; corrected by adding 1.0f
		// to the mouse coordinates (just another offset!)
		hex.x = static_cast<int32_t>(floor((mouse_x + mouse_y + 1.0f) / 2.0f));
		hex.y = static_cast<int32_t>(floor(mouse_y)) - (hex.x / 2); 

		return hex;
	}
*/
}

var _h = hexToScreen(200 /* map size */ - 1, 0)
hexOffsetX = _hexOffsetX - _h.x
hexOffsetY = _hexOffsetY - _h.y

var hexOverlay = null

// 200x200 hex grid
var hexMatrix = []
for(var i = 0; i < 200; i++) {
	var t = [];
	for(var j = 0; j < 200; j++)
		t.push(0);
	hexMatrix.push(t);
}

var cursor = {x: 10, y: 10}

heart.preload = function() {
	function load(file) {
		heart.graphics.newImage("tiles/"+file, function(r) { images[file] = r; })
	}
	load("edg6009.png")
	load("edg1001.png")
	load("edg4003.png")
	load("cav2002.png")
	load("cav1004.png")
	load("edg2003.png")
	load("edg6004.png")
	load("cav3001.png")
	load("cav2003.png")
	load("cav4013.png")
	load("edg2000.png")
	load("cav4009.png")
	load("edg4004.png")
	load("cav4001.png")
	load("cav2001.png")
	load("edg6008.png")
	load("cav1007.png")
	load("grid000.png")
	load("edg2001.png")
	load("edg3000.png")
	load("cav4012.png")
	load("cav4002.png")
	load("edg6002.png")
	load("edg4005.png")
	load("cav3003.png")
	load("cav1008.png")
	load("cav3000.png")
	load("cav4006.png")
	load("cav4010.png")
	load("cav4014.png")
	load("cav3002.png")
	load("edg1002.png")
	load("cav1005.png")
	load("cav2000.png")
	load("cav1000.png")
	load("edg4000.png")
	load("grt2000.png")
	load("cav4004.png")
	load("cav3005.png")
	load("edg6007.png")
	load("edg6005.png")
	load("edg1003.png")
	load("cav1009.png")
	load("cav4000.png")
	load("edg5000.png")
	load("cav4005.png")
	load("cav4008.png")
	load("road02.png")
	load("cav3004.png")
	load("edg4002.png")
	load("cav1003.png")
	load("edg4001.png")
	load("cav4011.png")
	load("cav4007.png")
	load("cav1006.png")
	load("cav1001.png")
	load("cav4003.png")
	load("cav1002.png")

	heart.graphics.newImage("hex_outline.png", function(r) { hexOverlay = r; })
}

heart.load = function() {
	heart.attach("cnv");
	$.get('derp.json', function(data) {
		matrix = JSON.parse(data)["tiles"]
		console.log("loaded (" + matrix.length + " entries)")
	})
}

heart.keydown = function(k) {
	if(k == 'down') cameraY += 15
	if(k == 'right') cameraX += 15
	if(k == 'left') cameraX -= 15
	if(k == 'up') cameraY -= 15
}

heart.draw = function() {
	heart.graphics.setColor(255, 255, 255)

	var mousePos = heart.mouse.getPosition();
	//var mouseTile = tileFromScreen(mousePos[0], mousePos[1])
	var mouseHex = hexFromScreen(mousePos[0] + cameraX, mousePos[1] + cameraY)

	// draw tile grid
	if(matrix === null) return;
	for(var i = 0; i < matrix.length; i++) {
		for(var j = 0; j < matrix[0].length; j++) {
			var tile = matrix[j][i]
			var x = 99-i
			var y = j

			if(images[tile] !== undefined) {
				var scr = tileToScreen(x, y)
				heart.graphics.draw(images[tile], scr.x - cameraX, scr.y - cameraY)
			}
		}
	}

	// draw hex grid
	for(var i = 0; i < hexMatrix.length; i++) {
		for(var j = 0; j < hexMatrix[0].length; j++) {
			var scr = hexToScreen(i, j)
			heart.graphics.draw(hexOverlay, scr.x - 16 - cameraX, scr.y - 12 - cameraY)
			if(i == mouseHex.x && j == mouseHex.y) {
				heart.graphics.print("m", scr.x - 3 - cameraX, scr.y - 3 - cameraY)
			}
		}
	}

	heart.graphics.print("mh: " + mouseHex.x + "," + mouseHex.y, 5, 15)
}

</script>
</head>
<body>

<canvas id="cnv" width="800" height="600">your browser doesn't support &lt;canvas&gt;</canvas>

</body>
</html>