<html>
<head>
<title>heart.js test</title>
<script src="heart.js"></script>
<script src="jquery-1.11.1.min.js"></script>
<script>
var MAP_NAME = "NAVARRO"
var floorMap = null
var roofMap = null
var gObjects = []
var imageGroups = {}
var size = 6
var tile_width = 80
var tile_height = 36
var images = {}
var imageOffsets = {}
var cameraX = 3490
var cameraY = 1365//1200
var showHexOverlay = false
var SCREEN_WIDTH = 800, SCREEN_HEIGHT = 600
var currentElevation = 0
var isMouseDown = false
var currentSelection = null

var showFloor = true
var showRoof = true
var showObjects = true

function tileToScreen(x, y) {
	x = 99 - x // this algorithm expects x to be reversed
	var sx = 4752 + (32 * y) - (48 * x)
	var sy = (24 * y) + (12 * x)

   return {x: sx, y: sy}
}

function tileFromScreen(x, y) {
	var off_x = -4800 + x
	var off_y = y
	var xx = off_x - off_y * 4 / 3
	var tx = xx / 64

	if (xx >= 0) tx++
	tx = -tx
	var yy = off_y + off_x / 4
	ty = yy / 32
	if (yy < 0) ty--

	return {x: 99 - Math.round(tx), y: Math.round(ty)}
}

function hexToScreen(x, y) {
	var sx = 4816 - ((((x + 1) >> 1) << 5) + ((x >> 1) << 4) - (y << 4))
	var sy = ((12 * (x >> 1)) + (y * 12)) + 11

	return {x: sx, y: sy}
}

function hexFromScreen(x, y) {
	var x0 = 4800
	var y0 = 0
	var nx, ny

	if (x - x0 < 0)
		nx = (x - x0 + 1) / 16 - 1
	else
		nx = (x - x0) / 16

	if (y - y0 < 0)
		ny = (y - y0 + 1) / 12 - 1
	else
		ny = (y - y0) / 12

	if (Math.abs(nx) % 2 != Math.abs(ny) % 2)
		nx--;

	var xhBase = x0 + 16 * nx
	var yhBase = y0 + 12 * ny

	var hx = (4 * (yhBase - y0) - 3 * (xhBase - x0)) / 96
	var hy = (yhBase - y0) / 12 - hx / 2

	var dx = x - xhBase
	var dy = y - yhBase

	switch(dy)
	{
	  case 0:
	     if (dx < 12)
	     {
	    hy--;
	    break;
	 }
	 if (dx > 18)
	     {
	    if (hx % 2 == 1)
	       hy--;
	        hx--;
	        break;
	     }

	  case 1:
	     if (dx < 8)
	     {
	    hx--;
	    break;
	 }
	 if (dx > 23)
	     {
	    if (hx % 2 == 1)
	       hy--;
	    hx--;
	    break;
	 }

	  case 2:
	 if (dx < 4)
	     {
	    hy--;
	    break;
	 }
	     if (dx > 28)
	     {
	    if (hx % 2 == 1)
	       hy--;
	        hx--;
	    break;
	 }
	  default:
	     break;
	}


	return {x: Math.round(hx), y: Math.round(hy)}
}

var hexOverlay = null

// 200x200 hex grid
var hexMatrix = []
for(var i = 0; i < 200; i++) {
	var t = [];
	for(var j = 0; j < 200; j++)
		t.push(0);
	hexMatrix.push(t);
}

var cursor = {x: 10, y: 10}

function changeElevation(level) {
	currentElevation = level
	floorMap = gMap[level]["tiles"]["floor"]
	roofMap  = gMap[level]["tiles"]["roof"]
	gObjects = gMap[level]["objects"]
}

function getGroupByName(art) {
	return art.split("/")[1].slice(null, -1)
}

function loadImage(art, f) {
	heart.graphics.newImage(art+".png", function(r) { images[art] = r; if(f !== undefined) f(art, r.img) })
}

heart.preload = function() {
	$.ajaxSetup({async: false})

	var loadImages = null
	$.get(MAP_NAME + ".images.json", function(images_) { loadImages = images_ }, "json")

	for(var i = 0; i < loadImages.length; i++)
		loadImage(loadImages[i])
	console.log("loaded " + loadImages.length + " tiles")

	var loadOffsets = null
	$.get(MAP_NAME + ".offsets.json", function(offsets) { loadOffsets = offsets }, "json")

	var numOffsets = 0
	for(var image in loadOffsets) {
		imageOffsets[image] = loadOffsets[image]
		numOffsets++
	}

	console.log("loaded " + numOffsets + " offsets")

	$.get("images.json", function(images) {
		imageGroups = images
		for(var group in imageGroups)
			imageGroups[group].loaded = false
	}, "json")

	heart.graphics.newImage("hex_outline.png", function(r) { hexOverlay = r })
}

heart.load = function() {
	heart.attach("cnv");
	$.get(MAP_NAME+".json", function(map) {
		gMap = map
		changeElevation(0)
		console.log("loaded (" + map.length + " levels, level 0: " + floorMap.length + " tiles, " + gObjects.length + " objects on elevation)")
	}, "json")

	window.onmousewheel = function(evt) {
		var delta = Math.max(-1, Math.min(1, (evt.wheelDelta || -evt.detail)))
		onMousewheelScroll(delta)
        if (evt.preventDefault) evt.preventDefault();
	}

	$(".imagegroupheader").click(function() {
		var el = $(this).parent(), group = el.attr("group");
		el.toggleClass("collapsed")
		if(!el.hasClass("collapsed") && !imageGroups[group].loaded) {
			// load group...
			console.log("loading group " + group)

			var loaded = 0
			for(var i = 0; i < imageGroups[group].length; i++) {
				loadImage(imageGroups[group][i].fullname, function(art, img) {
					imageOffsets[art] = {x: 0, y: 0} // hack

					$(img).attr("group", group)
					$(img).attr("art", art)
					$(img).attr("title", art)
					$(img).on("click", function(e) {
						var art = $(e.target).attr("art")
						var group = $(e.target).attr("group")
						console.log("click: " + art + " " + group)
						gObjects.push({type: group, orientation: 0, art: art, position: {x: cursor.x, y: cursor.y}})
						currentSelection = {type: "object", selection: gObjects[gObjects.length-1]}
						isMouseDown = true
					})
					el.append(img)
					el.append(" ")
				})
				loaded++
			}

			console.log("loaded " + loaded + " images from group " + group)
			imageGroups[group].loaded = true
		}
	})
}

heart.keydown = function(k) {
	if(k == 'down') cameraY += 15
	if(k == 'right') cameraX += 15
	if(k == 'left') cameraX -= 15
	if(k == 'up') cameraY -= 15
	if(k == 'q') { if(currentElevation-1 >= 0) changeElevation(currentElevation-1) }
	if(k == 'e') { if(currentElevation+1 < gMap.length) changeElevation(currentElevation+1) }
	if(k == 'r') { showRoof = !showRoof }
	if(k == 'f') { showFloor = !showFloor }
	if(k == 'o') { showObjects = !showObjects }
}

heart.mousepressed = function(x,y) {
	var mouseHex = hexFromScreen(x + cameraX, y + cameraY)
	currentSelection = null
	for(var i = 0; i < gObjects.length; i++) {
		if(gObjects[i].position.x == mouseHex.x && gObjects[i].position.y == mouseHex.y) {
			currentSelection = {type: "object", selection: gObjects[i]}
			console.log("select: " + gObjects[i].art)
			break;
		}
	}
	isMouseDown = true
}

heart.mousereleased = function() {
	isMouseDown = false
}

heart.mousemoved = function(x,y) {
	cursor = hexFromScreen(x + cameraX, y + cameraY)

	if(isMouseDown && currentSelection !== null && currentSelection.type === "object") {
		// move selected object
		var mouseHex = hexFromScreen(x + cameraX, y + cameraY)
		currentSelection.selection.position = mouseHex
	}
}

function onMousewheelScroll(delta) {
	if(currentSelection !== null && currentSelection.type === "object") {
		// change orientation of selected object
		var orientation = currentSelection.selection.orientation + delta
		if(orientation < 0) orientation = 5
		else if(orientation > 5) orientation = 0
		currentSelection.selection.orientation = orientation
	}
}

function drawTileMap(matrix, offsetY) {
	for(var i = 0; i < matrix.length; i++) {
		for(var j = 0; j < matrix[0].length; j++) {
			var tile = matrix[j][i]
			if(tile === "grid000") continue;
			var img = "art/tiles/" + tile

			if(images[img] !== undefined) {
				var scr = tileToScreen(i, j)
				scr.y += offsetY
				if(scr.x+tile_width < cameraX || scr.y+tile_height < cameraY ||
				   scr.x >= cameraX+SCREEN_WIDTH || scr.y >= cameraY+SCREEN_HEIGHT)
					continue;
				heart.graphics.draw(images[img], scr.x - cameraX, scr.y - cameraY)
			}
		}
	}
}

heart.draw = function() {
	heart.graphics.setColor(255, 255, 255)

	var mousePos = heart.mouse.getPosition()
	var mouseHex = hexFromScreen(mousePos[0] + cameraX, mousePos[1] + cameraY)
	var mouseTile = tileFromScreen(mousePos[0] + cameraX, mousePos[1] + cameraY)

	// draw tile grids
	if(showFloor && floorMap !== null)
		drawTileMap(floorMap, 0);

	// draw hex grid overlay
	if(showHexOverlay) {
		for(var i = 0; i < hexMatrix.length; i++) {
			for(var j = 0; j < hexMatrix[0].length; j++) {
				var scr = hexToScreen(i, j)
				heart.graphics.draw(hexOverlay, scr.x - 16 - cameraX, scr.y - 12 - cameraY)
				if(i == mouseHex.x && j == mouseHex.y) {
					heart.graphics.print("m", scr.x - 3 - cameraX, scr.y - 3 - cameraY)
				}
			}
		}
	}

	// draw objects
	if(showObjects) {
		for(var i = 0; i < gObjects.length; i++) {
			var obj = gObjects[i]
			var scr = hexToScreen(obj.position.x, obj.position.y)

			if(images[obj.art] === undefined)
				continue; // skip images we don't have

			var frameInfo = imageOffsets[obj.art].frameInfo
			if(frameInfo !== undefined) {
				var frame = frameInfo[obj.orientation * imageOffsets[obj.art].framesPerDirection]
				var offsetX = Math.floor(frame.w / 2) - imageOffsets[obj.art].x
				var offsetY = frame.h - imageOffsets[obj.art].y
				var scrX = scr.x - offsetX, scrY = scr.y - offsetY

				if(scrX + frame.w < cameraX || scrY + frame.h < cameraY ||
				   scrX >= cameraX+SCREEN_WIDTH || scrY >= cameraY+SCREEN_HEIGHT)
					continue;

				heart.ctx.drawImage(images[obj.art].img,
					frame.x, 0, frame.w, frame.h,
					scrX - cameraX,
					scrY - cameraY,
					frame.w, frame.h
				)
			}
			else {
				var w = images[obj.art].getWidth()
				var h = images[obj.art].getHeight()
				var offsetX = Math.floor(w / 2) - imageOffsets[obj.art].x
				var offsetY = h - imageOffsets[obj.art].y
				var scrX = scr.x - offsetX, scrY = scr.y - offsetY
				if(scrX + w < cameraX || scrY + h < cameraY ||
				   scrX >= cameraX+SCREEN_WIDTH || scrY >= cameraY+SCREEN_HEIGHT)
					continue
				heart.graphics.draw(images[obj.art], scrX - cameraX, scrY - cameraY)
			}

			if(obj.position.x === mouseHex.x && obj.position.y === mouseHex.y)
				heart.graphics.print("tile: " + obj.art + " offset: " + offsetX + ", " + offsetY + ", orientation: " + obj.orientation, 5, 30)
		}
	}

	if(showRoof && roofMap !== null)
		drawTileMap(roofMap, -96);

	if(!showHexOverlay) {
		var scr = hexToScreen(cursor.x, cursor.y)
		heart.graphics.draw(hexOverlay, scr.x - 16 - cameraX, scr.y - 12 - cameraY)
	}

	var tileImg = floorMap[mouseTile.y][mouseTile.x]
	heart.graphics.print("tile: " + tileImg, 5, 60)

	var scr = tileToScreen(mouseTile.x, mouseTile.y)
	//heart.graphics.print("X", scr.x - 3 - cameraX, scr.y - 3 - cameraY)
	//heart.graphics.print("scr: " + scr.x + ", " + scr.y, scr.x - 3 - cameraX, scr.y - 10 - cameraY)

	heart.graphics.print("mh: " + mouseHex.x + "," + mouseHex.y, 5, 15)
	heart.graphics.print("mt: " + mouseTile.x + "," + mouseTile.y, 100, 15)
}

</script>
<style>
	#groupcontainer {
		float: right;
		width: 25%;
	}

	.imagegroup {
		border: 1px solid black;
		height: 45%;
		overflow: auto;
	}

	.imagegroupheader {
		-webkit-user-select: none;
		-moz-user-select: none;
		-ms-user-select: none;
	}

	.collapsed {
		height: 1.2em;
		overflow: hidden;
	}

	.collapsed img {
		display: none;
	}
</style>
</head>
<body>

<canvas id="cnv" width="800" height="600">your browser doesn't support &lt;canvas&gt;</canvas>

<div id="groupcontainer">
	<div class="imagegroup collapsed" group="wall"><div class="imagegroupheader">walls</div></div><br>
	<div class="imagegroup collapsed" group="critter"><div class="imagegroupheader">critters</div></div><br>
	<div class="imagegroup collapsed" group="item"><div class="imagegroupheader">items</div></div><br>
	<div class="imagegroup collapsed" group="misc"><div class="imagegroupheader">misc</div></div>
</div>

</body>
</html>