<!-- DarkFO
     Copyright (c) 2014 darkf
     Licensed under the terms of the zlib license
 -->

<html>
<head>
<title>DarkFO: Play!</title>
<script src="heart.js"></script>
<script src="jquery-1.11.1.min.js"></script>
<script src="geometry.js"></script>
<script src="scripting.js"></script>
<script src="combat.js"></script>
<script src="critter.js"></script>
<script src="pathfinding-browser.js"></script>
<script>
"use strict";

var MAP_NAME = "GECKSETL" // name of the current map
var DEBUG = true // debug mode

var gMapScript = null
var floorMap = null
var roofMap = null
var images = {}
var imageInfo = null
var gObjects = []
var gMap = null
var currentElevation = 0 // current map elevation
var hexOverlay = null
//var cursor = {x: 10, y: 10}

// position of viewport camera (will be overriden by map starts or scripts)
var cameraX = 3580
var cameraY = 1020

// geometry constants
var TILE_WIDTH = 80
var TILE_HEIGHT = 36
var HEX_GRID_SIZE = 200 // hex grid is 200x200
var SCREEN_WIDTH = 800, SCREEN_HEIGHT = 600
var SCROLL_PADDING = 20 // how far the mouse has to be from an edge to scroll

var showHexOverlay = false // show hex grid?
var showCoordinates = false // show coordinates on hex grid?
var showPath = true // show player's path?
var showFloor = true // show floor tiles?
var showRoof = true // show roof tiles?
var showObjects = true // show objects?

var doLoadScripts = true // should we load scripts?
var doUpdateCritters = false // should we give critters heartbeats?
var doTimedEvents = true // should we handle registered timed events?
var doCombat = false // allow combat?
var doUseWeaponModel = false // use weapon model for NPC models?
var doLoadItemInfo = true // load item information (such as inventory images)?

var gameTickTime = 0 // in Fallout 2 ticks (elapsed seconds * 10)
var lastGameTick = 0 // real time of the last game tick
var combat = null // combat object
var inCombat = false // are we currently in combat?
var gameHasFocus = false // do we have input focus?

var isLoading = true // are we currently loading a map?
var loadingImagesLoaded = 0 // how many images we've loaded
var loadingImagesTotal = 0 // out of this total

var proFiles = {}
var lstFiles = {}
var messageFiles = {}

function cloneStats(stats) { return $.extend({}, stats) }
function addStats(a, b) {
	var w = cloneStats(a)
	for(var prop in b) {
		w[prop] += b[prop]
	}
	return w
}
function calcStats(obj, pro) {
	var stats = addStats(pro.extra.baseStats, pro.extra.bonusStats)
	// todo: armor
	return stats
}
function reprStats(stats) {
	return JSON.stringify(stats) // todo
}

// the player object
var player = {position: {x: 94, y: 109}, orientation: 2, frame: 0,
              art: "art/critters/hmjmpsaa", isPlayer: true, anim: "idle", lastFrameTime: 0,
              path: null, animCallback: null,
          	  baseStats: {STR: 8, PER: 5, END: 5, CHR: 6, INT: 5, AGI: 6, LUK: 5, HP: 100},
          	  bonusStats: {STR: 0, PER: 0, END: 0, CHR: 0, INT: 0, AGI: 0, LUK: 0, HP: 0},
          	  leftHand: null, rightHand: null, weapon: null, armor: null,
          	  dead: false, name: "Player", gender: "male",
          	  skills: {"Repair": 25, "Big Guns": 25, "Outdoorsman": 25, "Traps": 25, "Barter": 25,
          	  		   "Melee": 25, "Throwing": 25, "Steal": 25, "Doctor": 25, "Sneak": 25,
          	  		   "Unarmed": 25, "Speech": 25, "First Aid": 25, "Lockpick": 25, "Science": 25,
          	  		   "Gambling": 25, "Small Guns": 50, "Energy Weapons": 50},
          	  inventory: [
          	  	{type: "misc", name: "Money", pid: 41, pidID: 41, amount: 1337, pro: {textID: 4100, extra: {cost: 1}, invFRM: 117440552}, invArt: 'art/inven/cap2'}
          	  ]}
player.stats = cloneStats(player.baseStats)
player.toString = function() { return "The Dude" }

function repr(obj) { return JSON.stringify(obj, null, 2) }

function loadMessage(name) {
	$.get("data/text/english/game/" + name + ".msg", function(msg) {
		if(messageFiles[name] === undefined)
			messageFiles[name] = {}

		// parse message file
		var lines = msg.split(/\r|\n/)

		// preprocess and merge lines
		for(var i = 0; i < lines.length; i++) {
			// comments/blanks
			if(lines[i][0] === '#' || lines[i].trim() === '') {
				lines.splice(i--, 1)
				continue
			}

			// probably a continuation -- merge it with the last line
			if(lines[i][0] !== '{') {
				lines[i-1] += lines[i]
				lines.splice(i--, 1)
				continue
			}
		}

		for(var i = 0; i < lines.length; i++) {
			// e.g. {100}{}{You have entered a dark cave in the side of a mountain.}
			var m = lines[i].match(/\{(\d+)\}\{.*\}\{(.*)\}/)
			if(m === null)
				throw "message parsing: not a valid line: " + lines[i]
			// HACK: replace unicode replacement character with an apostrophe (because the Web sucks at character encodings)
			messageFiles[name][m[1]] = m[2].replace(/\ufffd/g, "'")
		}
	}, "text").fail(function(err) { console.log("message loading error: "  + err) })
}

function getMessage(name, id) {
	if(messageFiles[name] !== undefined && messageFiles[name][id] !== undefined)
		return messageFiles[name][id]
	else {
		loadMessage(name)
		if(messageFiles[name] !== undefined && messageFiles[name][id] !== undefined)
			return messageFiles[name][id]
		else null
	}
}

function loadLst(lst) {
	var ret = null
	$.get("data/" + lst + ".lst", function(lst) {
		ret = lst.split('\n')
	}, "text").fail(function(err) { console.log("lst loading error: "  + err) })
	return ret
}

function getLstId(lst, id) {
	if(lstFiles[lst] === undefined)
		lstFiles[lst] = loadLst(lst)
	if(lstFiles[lst] === undefined)
		return null

	return lstFiles[lst][id]
}

function lazyLoadImage(art, callback, isHeartImg) {
	var img = new Image()
	img.src = art + '.png'
	img.onload = function() {
		images[art] = new heart.HeartImage(img)
		if(callback)
			callback(isHeartImg ? images[art] : img)
	}
}

function pad(n, width, z) {
  z = z || '0';
  n = n + '';
  return n.length >= width ? n : new Array(width - n.length + 1).join(z) + n;
}

function getPROType(pid) {
	var map = {0: 'items', 1: 'critters', 2: 'scenery', 3: 'walls', 4: 'tiles', 5: 'misc'}
	return map[(pid >> 24) & 0xff]
}

function loadPRO(pid, pidID) {
	if(proFiles[pid] !== undefined)
		return proFiles[pid]

	var r = null
	$.get('proto/' + getPROType(pid) + '/' + pad(pidID, 8) + '.pro.json', function(pro) {
		r = pro
	}, 'json')

	proFiles[pid] = r
	return r
}

function getPROTypeName(type) {
	// singular
	var map = {0: 'item', 1: 'critter', 2: 'scenery', 3: 'wall', 4: 'tile', 5: 'misc'}
	return map[type]
}

function getPROSubTypeName(type) {
	var map = {0: 'armor', 1: 'container', 2: 'drug', 3: 'weapon', 4: 'ammo', 5: 'misc', 6: 'key'}
	return map[type]
}

function makePID(type, pid) {
	return (type << 24) | pid
}

function createObjectWithPID(objType, pid, sid) {
	var pidID = makePID(objType, pid)
	var pro = loadPRO(pidID, pid)
	var obj = {type: getPROTypeName(objType), pro: pro, pid: pidID, pidID: pid, amount: 1}
	if(objType === 0) { // item
		obj.subtype = getPROSubTypeName(pro.extra.subtype)
		obj.name = getMessage("pro_item", pro.textID)

		var invPID = pro.extra.invFRM & 0xffff
		console.log("invPID: " + invPID + ", also: " + pid)
		if(invPID !== 0xffff)
			obj.invArt = "art/inven/" + getLstId("art/inven/inven", invPID).split('.')[0]
	} else {
		console.log("createObjectWithPID: not an item")
	}

	obj.art = "art/items/RESERVED" // todo: get art from pro

	if(obj.pro !== undefined && sid !== undefined && obj.pro.extra.scriptID != sid)
		console.log("!!! createObjectWithPID: need to change script ID (" + obj.pro.extra.scriptID +
			" to " + sid + ")")

	return obj
}

function objectAddItem(obj, item, count) {
	for(var i = 0; i < obj.inventory.length; i++) {
		if(obj.inventory[i].pidID === item.pidID) { // todo: pidID or pid?
			obj.inventory[i].amount += count
			return
		}
	}

	// add new inventory object
	var item_ = $.extend(true, {}, item) // clone the item (deep copy)
	item_.amount = count // set the amount
	obj.inventory.push(item_)
}

function objectGetMoney(obj) {
	var MONEY_PID = 41
	for(var i = 0; i < obj.inventory.length; i++) {
		if(obj.inventory[i].pid === MONEY_PID) {
			return obj.inventory[i].amount
		}
	}

	return 0
}

function objectSingleAnim(obj, reversed, callback) {
	if(reversed) obj.frame = imageInfo[obj.art].numFrames - 1
	else obj.frame = 0
	obj.lastFrameTime = 0
	obj.anim = reversed ? "reverse" : "single"
	obj.animCallback = (callback !== undefined) ? callback : (function() { obj.anim = null  })
}

function objectUpdateAnimation(obj) {
	var time = heart.timer.getTime()
	var fps = 8 // todo: get FPS from image info

	if(time - obj.lastFrameTime >= 1000/fps) {
		if(obj.anim === "reverse") obj.frame--
		else obj.frame++
		obj.lastFrameTime = time

		if(obj.frame === -1 || obj.frame === imageInfo[obj.art].numFrames) {
			// animation is done
			if(obj.anim === "reverse") obj.frame++
			else obj.frame--
			if(obj.animCallback)
				obj.animCallback()
		}
	}
}

function useObject(obj) {
	// todo: check if you can use it

	if(obj._script && obj._script.use_p_proc !== undefined) {
		obj._script.source_obj = player
		obj._script.self_obj = obj
		obj._script.use_p_proc()
	}
	else if(obj.script !== undefined && !obj._script)
		console.log("object used has script but is not loaded: " + obj.script)

	// todo: check script overrides
	// also check object type
	objectSingleAnim(obj)

	if((obj.type === "scenery" && obj.subtype === "door") ||
		obj.art.indexOf("door") !== -1 || obj.art.indexOf("locker") !== -1) {
		// open/closable doors/containers
		if(!obj.open) obj.open = true
		else obj.open = false
		objectSingleAnim(obj, !obj.open)
	}	
}

// Draws a line between a and b, returning the first object hit
function hexLinecast(a, b) {
	var line = hexLine(a, b)
	if(line === null)
		return null
	for(var i = 0; i < line.length; i++) {
		// todo: we could optimize this by only
		// checking in a certain radius of `a`
		var obj = objectsAtPosition(line[i])
		if(obj.length !== 0)
			return obj[0]
	}
	return null
}

function objectsAtPosition(position) {
	var ret = []
	for(var i = 0; i < gObjects.length; i++) {
		if(gObjects[i].position.x === position.x && gObjects[i].position.y === position.y) {
			ret.push(gObjects[i])
		}
	}
	return ret
}

function critterAtPosition(position) {
	var objects = objectsAtPosition(position)
	for(var i = 0; i < objects.length; i++) {
		if(objects[i].type === "critter")
			return objects[i]
	}
	return null
}

function loadObjectScripts(objects) {
	var goodScripts = {} // cache scripts that don't load
	for(var i = 0; i < objects.length; i++) {
		var scriptName = objects[i].script
		if(scriptName === undefined || objects[i]._script !== undefined) continue
		if(goodScripts[scriptName] === false) continue

		console.log("loading " + scriptName + " for " + objects[i].art + " (" + objects[i].type + ")" +
			" @ " + objects[i].position.x + ", " + objects[i].position.y)
		var script = scriptingEngine.loadScript(scriptName)
		if(script === null) {
			console.log("load script failed for " + scriptName)
			goodScripts[scriptName] = false
			continue
		} else {
			objects[i]._script = script
		}
	}
}

function changeElevation(level, updateScripts) {
	currentElevation = level
	floorMap = gMap.levels[level]["tiles"]["floor"]
	roofMap  = gMap.levels[level]["tiles"]["roof"]
	gObjects = gMap.levels[level]["objects"]

	if(updateScripts !== false) {
		loadObjectScripts(gObjects)
		scriptingEngine.updateMap(gMapScript, gObjects, currentElevation)
	}
}

// Initialize various objects, such as items.
function initObjects(objects) {
	for(var i = 0; i < objects.length; i++) {
		var obj = objects[i]
		if(obj.type === "critter") {
			initObjects(obj.inventory)
			continue // critters are handled separately
		}

		if(obj.type === "item") { // load item inventory art
			obj.pro = loadPRO(obj.pid, obj.pidID)
			if(obj.pro === null) continue

			obj.name = getMessage("pro_item", obj.pro.textID)

			var invPID = obj.pro.extra.invFRM & 0xffff
			if(invPID !== 0xffff)
				obj.invArt = "art/inven/" + getLstId("art/inven/inven", invPID).split('.')[0]
		}
		else if(obj.type === "scenery") {
			obj.pro = loadPRO(obj.pid, obj.pidID)
			if(obj.pro === null) continue
			var subtypeMap = {0: "door", 1: "stairs", 2: "elevator", 3: "ladder",
							  4: "ladder", 5: "generic"}
			obj.subtype = subtypeMap[obj.pro.extra.subType]

			if(obj.subtype === "door")
				obj.open = false
		}
	}
}

// Initialize critters (mainly loading inventory and .PRO files)
function initCritters(objects) {
	// load .PRO prototypes for all critters
	for(var i = 0; i < objects.length; i++) {
		var obj = objects[i]
		if(obj.type !== "critter") continue
		obj.pro = loadPRO(obj.pid, obj.pidID)
		obj.stats = calcStats(obj, obj.pro)
		obj.skills = obj.pro.extra.skills
		obj.name = getMessage("pro_crit", obj.pro.textID)

		// PROs for weapons
		for(var j = 0; j < obj.inventory.length; j++) {
			var inv = obj.inventory[j]
			if(inv.pro === undefined)
				inv.pro = loadPRO(inv.pid, inv.pidID)

			if(inv.subtype === "weapon") {
				if(obj.leftHand === undefined) {
					var wep = new Weapon(inv)
					if(wep.canEquip(obj))
						obj.leftHand = wep
				}
				else if(obj.rightHand === undefined) {
					var wep = new Weapon(inv)
					if(wep.canEquip(obj))
						obj.rightHand = wep
				}
				//console.log("left: " + obj.leftHand + " | right: " + obj.rightHand)
			}
		}

		// default to punches
		if(!obj.leftHand)
			obj.leftHand = new Weapon("punch")
		if(!obj.rightHand)
			obj.rightHand = new Weapon("punch")

		// set them in their proper idle state for the weapon
		obj.art = critterGetAnim(obj, "idle")
	}
}

function centerCamera(around) {
	var scr = hexToScreen(around.x, around.y)
	cameraX = Math.max(0, scr.x - SCREEN_WIDTH/2)
	cameraY = Math.max(0, scr.y - SCREEN_HEIGHT/2)
}

function loadMap(mapName) {
	function load(file, callback) {
		if(images[file] !== undefined) return // don't load more than once
		loadingImagesTotal++
		heart.graphics.newImage(file+".png", function(r) {
			images[file] = r
			loadingImagesLoaded++
			if(callback) callback(r)
		})
	}

	isLoading = true
	loadingImagesTotal = 0
	loadingImagesLoaded = 0

	// clear any previous objects/events
	gMap = null
	gObjects = null
	gMapScript = null
	scriptingEngine.reset()

	console.log("loading map " + mapName)

	$.get("maps/" + mapName + ".images.json", function(images) {
		for(var i = 0; i < images.length; i++)
			load(images[i])
		console.log("loading " + images.length + " images")
	}, "json")

	if(imageInfo === null)
		$.get("art/imageMap.json", function(offsets) { imageInfo = offsets }, "json")

	$.get("maps/"+mapName+".json", function(map) {
		gMap = map

		if(doLoadScripts === true) {
			scriptingEngine.init(player, mapName)
			gMapScript = scriptingEngine.loadScript(mapName)

			// warp to the default position (may be overridden by map script)
			player.position = gMap.startPosition
			player.orientation = gMap.startOrientation

			changeElevation(0, false)
			loadObjectScripts(gObjects)
			scriptingEngine.enterMap(gMapScript, gObjects, 0)
			scriptingEngine.updateMap(gMapScript, gObjects, currentElevation)
		}
		else changeElevation(0, false)

		// todo: is map_enter_p_proc called on elevation change?
		console.log("loaded (" + map.length + " levels, level 0: " + floorMap.length + " tiles, " + gObjects.length + " objects on elevation)")
	}, "json")

	// load some testing art
	load("art/critters/hmjmpsat")
	
	load("art/critters/navgulij")
	load("art/critters/navgulia")
	load("art/critters/navgulab")
	load("art/critters/naghulab")

	load("art/critters/naghulja")
	load("art/critters/naghuljb")

	load("art/critters/hanpwraa")
	load("art/critters/hanpwrab")
	load("art/critters/hanpwraq")
	load("art/critters/hanpwria")
	load("art/critters/hanpwrib")
	load("art/critters/hanpwrij")

	load("hex_outline", function(r) { hexOverlay = r })

	if(doCombat === true && DEBUG === true) {
		// for testing
		var a = gObjects[1175]
		var b = gObjects[1260]
		gObjects = [a, b]

		a.art = "art/critters/hanpwraa"
		b.art = "art/critters/hanpwraa"
	}

	for(var level = 0; level < gMap.levels.length; level++) {
		if(doLoadItemInfo !== false)
			initObjects(gMap.levels[level]["objects"])
		initCritters(gMap.levels[level]["objects"])
	}

	centerCamera(player.position)
}

heart.load = function() {
	heart.attach("cnv")
	$.ajaxSetup({async: false})

	loadMap(MAP_NAME) // load initial map

	$("#cnv").mouseenter(function() { gameHasFocus = true }).
	          mouseleave(function() { gameHasFocus = false })

	drawInventory($("#playerInventory"), player)
}

function drawInventory($el, obj, clickCallback) {
	$el.html("")
	for(var i = 0; i < obj.inventory.length; i++) {
		if(obj.inventory[i].invArt === undefined) { // make a guess
			var s = obj.inventory[i].art.split('/')
			var inventoryImage = 'art/inven/' + s[s.length-1]
		} else
			var inventoryImage = obj.inventory[i].invArt

		console.log("inv img: " + inventoryImage)
		if(images[inventoryImage] === undefined)
			lazyLoadImage(inventoryImage, null, false)
		var img = $("<img>").attr("src", inventoryImage+'.png').
		          attr("width", 90).attr("height", 60) // 90x60 // 70x40
		img.attr("title", obj.inventory[i].name)
		if(clickCallback !== undefined)
			(function(invObj) {
				img.click(function() { clickCallback(invObj, obj) })
			})(obj.inventory[i])
		$el.append(img).append("x" + obj.inventory[i].amount)
	}
}

heart.mousepressed = function(x, y, btn) {
	if(isLoading === true) return
	if(btn !== "l") return

	var mousePos = heart.mouse.getPosition()
	var mouseHex = hexFromScreen(mousePos[0] + cameraX, mousePos[1] + cameraY)

	// todo: object highlights/usage
	
	critterWalkTo(player, mouseHex, true)
}

heart.keydown = function(k) {
	if(isLoading === true) return
	var mousePos = heart.mouse.getPosition()
	var mouseHex = hexFromScreen(mousePos[0] + cameraX, mousePos[1] + cameraY)

	if(k == 'down') cameraY += 15
	if(k == 'right') cameraX += 15
	if(k == 'left') cameraX -= 15
	if(k == 'up') cameraY -= 15
	if(k == 'q') { if(currentElevation-1 >= 0) changeElevation(currentElevation-1) }
	if(k == 'e') { if(currentElevation+1 < gMap.levels.length) changeElevation(currentElevation+1) }
	if(k == 'r') { showRoof = !showRoof }
	if(k == 'f') { showFloor = !showFloor }
	if(k == 'o') { showObjects = !showObjects }
	if(k == 't') {
		for(var i = 0; i < gObjects.length; i++) {
			if(gObjects[i].position.x === mouseHex.x && gObjects[i].position.y === mouseHex.y) {
				console.log("object at index " + i)
				if(gObjects[i]._script && gObjects[i]._script.talk_p_proc !== undefined) {
					console.log("calling talk proc")
					gObjects[i]._script.talk_p_proc()
				}
				break
			}
		}
	}
	if(k == 'i') {
		for(var i = 0; i < gObjects.length; i++) {
			if(gObjects[i].position.x === mouseHex.x && gObjects[i].position.y === mouseHex.y) {
				var hasScripts = (gObjects[i].script !== undefined ? ("yes (" + gObjects[i].script + ")") : "no") + " " + (gObjects[i]._script === undefined ? "and is NOT loaded" : "and is loaded")
				console.log("object is at index " + i + ", of type " + gObjects[i].type + ", has art " + gObjects[i].art + ", and has scripts? " + hasScripts)
			}
		}
	}
	if(k == 'm') {
		critterWalkTo(player, mouseHex)
	}
	if(k == 'j') {
		critterWalkTo(player, mouseHex, true)
	}
	if(k == 'g') {
		if(!inCombat || !combat.inPlayerTurn || player.anim !== "idle") {
			console.log("You can't do that yet.")
			return
		}

		if(player.AP < 4) {
			console.log("You don't have enough AP for that.")
			return
		}

		for(var i = 0; i < combat.critters.length; i++) {
			if(combat.critters[i].position.x === mouseHex.x && combat.critters[i].position.y === mouseHex.y) {
				player.AP -= 4
				console.log("Attacking...")
				combat.attack(player, combat.critters[i])
				break
			}
		}
	}

	if(k == 'w') {
		for(var i = 0; i < gObjects.length; i++) {
			if(gObjects[i]._script !== undefined && gObjects[i]._script.timed_event_p_proc !== undefined) {
				console.log("calling timed_event_p_proc(1) on " + gObjects[i].script)
				scriptingEngine.timedEvent(gObjects[i]._script, 1)
			}
		}
	}
	if(k == 'c') {
		if(!doCombat) return
		if(inCombat === true && combat.inPlayerTurn === true) {
			console.log("[TURN]")
			combat.nextTurn()
		}
		else if(inCombat === true) {
			console.log("Wait your turn...")
		}
		else {
			console.log("[COMBAT BEGIN]")
			inCombat = true
			combat = new Combat(gObjects, player)
			combat.nextTurn()
		}
	}

	if(k == 'y') {
		var obj = objectsAtPosition(mouseHex)[0]
		if(obj !== undefined) {
			var hit = hexLinecast(player.position, obj.position)
			console.log("hit obj: " + hit.art)
		}
	}

	if(k == 'v') {
		var obj = objectsAtPosition(mouseHex)[0]
		if(obj !== undefined) {
			console.log("PID: " + obj.pid)
			console.log("inventory: " + JSON.stringify(obj.inventory))

			drawInventory($("#inventory"), obj)
		}
	}

	if(k == 'u') {
		var obj = objectsAtPosition(mouseHex)[0]
		if(obj !== undefined)
			useObject(obj)
	}
}

function recalcPath(start, goal) {
	var matrix = new Array(HEX_GRID_SIZE)

	for(var y = 0; y < HEX_GRID_SIZE; y++)
		matrix[y] = new Array(HEX_GRID_SIZE)

	for(var i = 0; i < gObjects.length; i++) {
		var obj = gObjects[i]
		matrix[obj.position.y][obj.position.x] = 1
	}

	var grid = new PF.Grid(HEX_GRID_SIZE, HEX_GRID_SIZE, matrix)
	var finder = new PF.AStarFinder()
	var path = finder.findPath(start.x, start.y, goal.x, goal.y, grid)
	return path
}

function longestSequenceWithoutTurning(start, path, index) {
	// todo: make logic less complex
	var firstDir = directionOfDelta(start.x, start.y, path[index][0], path[index][1])
	if(index+1 >= path.length)
		return {seq: 1, lastPosition: {x: path[index][0], y: path[index][1]}, firstDirection: firstDir}

	var pos = path[index]
	var dir = firstDir
	var n = 1
	for(var i = index+1; i < path.length; i++) {
		//console.log("i " + i)
		var deltaDir = directionOfDelta(pos[0], pos[1], path[i][0], path[i][1])
		//console.log("deltaDir: " + deltaDir)
			         
		if(deltaDir !== dir) {
			//console.log("bad deltaDir: " + deltaDir)
			return {seq: n, lastPosition: {x: path[i-1][0], y: path[i-1][1]}, firstDirection: firstDir}
		}
		n++
		pos = path[i]
	}

	return {seq: n, lastPosition: {x: pos[0], y: pos[1]}, firstDirection: firstDir}
}

heart.update = function() {
	if(isLoading === true) {
		if(loadingImagesLoaded === loadingImagesTotal) isLoading = false
		else return
	}
	var time = heart.timer.getTime()

	if(gameHasFocus) {
		var mousePos = heart.mouse.getPosition()
		if(mousePos[0] <= SCROLL_PADDING) cameraX -= 15
		if(mousePos[0] >= SCREEN_WIDTH-SCROLL_PADDING) cameraX += 15

		if(mousePos[1] <= SCROLL_PADDING) cameraY -= 15
		if(mousePos[1] >= SCREEN_HEIGHT-SCROLL_PADDING) cameraY += 15
	}

	if(time - lastGameTick >= 1000/10) { // 10 Hz game tick
		lastGameTick = time
		gameTickTime++

		if(doTimedEvents === true && inCombat !== true) {
			// check and update timed events
			var timedEvents = scriptingEngine.timeEventList
			for(var i = 0; i < timedEvents.length; i++) {
				timedEvents[i].ticks--
				if(timedEvents[i].ticks <= 0) {
					scriptingEngine.info("timed event triggered", "timer")
					timedEvents[i].fn()
					timedEvents.splice(i--, 1)
				}
			}
		}

		critterUpdateAnimation(player)

		for(var i = 0; i < gObjects.length; i++) {
			if(gObjects[i].type === "critter") {
				if(doUpdateCritters === true && inCombat !== true && gObjects[i]._script !== undefined)
					scriptingEngine.updateCritter(gObjects[i]._script)
				critterUpdateAnimation(gObjects[i])
			}
			else if(gObjects[i].anim === "single" || gObjects[i].anim === "reverse")
				objectUpdateAnimation(gObjects[i])
		}
	}
}

function drawTileMap(matrix, offsetY) {
	for(var i = 0; i < matrix.length; i++) {
		for(var j = 0; j < matrix[0].length; j++) {
			var tile = matrix[j][i]
			if(tile === "grid000") continue
			var img = "art/tiles/" + tile

			if(images[img] !== undefined) {
				var scr = tileToScreen(i, j)
				scr.y += offsetY
				if(scr.x+TILE_WIDTH < cameraX || scr.y+TILE_HEIGHT < cameraY ||
				   scr.x >= cameraX+SCREEN_WIDTH || scr.y >= cameraY+SCREEN_HEIGHT)
					continue
				heart.graphics.draw(images[img], scr.x - cameraX, scr.y - cameraY)
			}
		}
	}
}

function drawObject(obj) {
	var scr = hexToScreen(obj.position.x, obj.position.y)

	if(images[obj.art] === undefined)
		throw "No art for object: " + obj.art // skip images we don't have

	var info = imageInfo[obj.art]
	if(info === undefined)
		throw "No image map info for: " + obj.art

	var frameIdx = 0
	if(obj.frame !== undefined)
		frameIdx += obj.frame

	if(!(obj.orientation in info.frameOffsets))
		obj.orientation = 0 // ...
	var frameInfo = info.frameOffsets[obj.orientation][frameIdx]
	var dirOffset = info.directionOffsets[obj.orientation]
	var offsetX = Math.floor(frameInfo.w / 2) - dirOffset.x - frameInfo.ox
	var offsetY = frameInfo.h - dirOffset.y - frameInfo.oy
	var scrX = scr.x - offsetX, scrY = scr.y - offsetY

	if(scrX + frameInfo.w < cameraX || scrY + frameInfo.h < cameraY ||
	   scrX >= cameraX+SCREEN_WIDTH || scrY >= cameraY+SCREEN_HEIGHT)
		return // out of screen bounds, no need to draw

	heart.ctx.drawImage(images[obj.art].img,
		frameInfo.sx, 0, frameInfo.w, frameInfo.h,
		scrX - cameraX,
		scrY - cameraY,
		frameInfo.w, frameInfo.h
	)
}

heart.draw = function() {
	if(isLoading === true) {
		heart.graphics.setColor(0, 0, 0)
		var w = 256, h = 40
		var w2 = (loadingImagesLoaded / loadingImagesTotal) * w
		// draw a loading progress bar
		heart.graphics.rectangle("stroke", SCREEN_WIDTH/2 - w/2, SCREEN_HEIGHT/2,
				w, h)
		heart.graphics.rectangle("fill", SCREEN_WIDTH/2 - w/2 + 2, SCREEN_HEIGHT/2 + 2,
				w2 - 4, h - 4)
		return
	}
	heart.graphics.setColor(255, 255, 255)

	var mousePos = heart.mouse.getPosition()
	var mouseHex = hexFromScreen(mousePos[0] + cameraX, mousePos[1] + cameraY)
	var mouseTile = tileFromScreen(mousePos[0] + cameraX, mousePos[1] + cameraY)

	// draw tile grids
	if(showFloor === true && floorMap !== null)
		drawTileMap(floorMap, 0);

	// draw hex grid overlay
	if(showHexOverlay === true || showCoordinates === true) {
		for(var y = 0; y < HEX_GRID_SIZE; y++) {
			for(var x = 0; x < HEX_GRID_SIZE; x++) {
				var scr = hexToScreen(x, y)
				heart.graphics.draw(hexOverlay, scr.x - 16 - cameraX, scr.y - 12 - cameraY)
				if(showCoordinates === true) {
					heart.graphics.print(x + "," + y, scr.x - 3 - cameraX, scr.y - 3 - cameraY)
				}
				if(showCoordinates === false && (x === mouseHex.x && y === mouseHex.y)) {
					heart.graphics.print("m", scr.x - 3 - cameraX, scr.y - 3 - cameraY)
				}
			}
		}
	} else {
		var scr = hexToScreen(mouseHex.x, mouseHex.y)
		heart.graphics.draw(hexOverlay, scr.x - 16 - cameraX, scr.y - 12 - cameraY)

		if(showPath === true && player.path !== null) {
			for(var i = 0; i < player.path.path.length; i++) {
				var scr = hexToScreen(player.path.path[i][0], player.path.path[i][1])
				heart.graphics.draw(hexOverlay, scr.x - 16 - cameraX, scr.y - 12 - cameraY)
			}
		} 
	}

	// draw objects and player
	if(showObjects === true) {
		for(var i = 0; i < gObjects.length; i++)
			drawObject(gObjects[i])

		drawObject(player)
	}

	if(showRoof === true && roofMap !== null)
		drawTileMap(roofMap, -96);

	if(floorMap[mouseTile.y] !== undefined) {
		var tileImg = floorMap[mouseTile.y][mouseTile.x]
		heart.graphics.print("tile: " + tileImg, 5, 60)
	}

	if(inCombat === true) {
		var whose = combat.whoseTurn === -1 ? "player" : combat.critters[combat.whoseTurn].art
		var AP = combat.whoseTurn === -1 ? player.AP : combat.AP[combat.whoseTurn]
		heart.graphics.print("[turn " + combat.turnNum + " of " + whose + " AP: " + AP + "]", SCREEN_WIDTH - 200, 15)
	}

	if(player.dead === true) {
		heart.graphics.setColor(255, 0, 0, 50)
		heart.graphics.rectangle("fill", 0, 0, SCREEN_WIDTH, SCREEN_HEIGHT)
	}

	heart.graphics.print("mh: " + mouseHex.x + "," + mouseHex.y, 5, 15)
	heart.graphics.print("mt: " + mouseTile.x + "," + mouseTile.y, 100, 15)
}

function dialogueReply(id) {
	scriptingEngine.dialogueReply(id)
}

</script>
<style>
	body {
		font-family: sans-serif;
	}

	#dialogue {
		float: right;
		width: 30%;
		height: 60%;
		border: 1px solid black;
		visibility: hidden;
		overflow: auto;
	}

	#inventory {
		border: 1px solid black;
		width: 800px;
		height: 120px;
		margin-top: 2px;
	}

	.verticalInventory {
		border: 1px solid black;
		width: 120px;
		height: 600px;
		margin-top: 2px;
	}

	#barterLeft {
		float: left;
	}

	#barterLeft, #barterRight {
		visibility: hidden;
		display: inline-block;
		position: relative;
	}

	#rightArea {
		float: right;
		width: 45%;
	}

	#playerInventory {
		float: right;
	}
</style>
</head>
<body>

<canvas id="cnv" width="800" height="600">your browser doesn't support &lt;canvas&gt;</canvas>

<div id="rightArea">
	<div id="barterLeft" class="verticalInventory"></div>
	<div id="barterRight" class="verticalInventory"></div>

	<div id="playerInventory" class="verticalInventory"></div>

	<div id="dialogue"></div>
</div>
<div id="inventory"></div>


</body>
</html>