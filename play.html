<html>
<head>
<title>heart.js test</title>
<script src="heart.js"></script>
<script src="jquery-1.11.1.min.js"></script>
<script src="scripting.js"></script>
<script src="combat.js"></script>
<script src="pathfinding-browser.js"></script>
<script>
"use strict";

var MAP_NAME = "GECKSETL"
var gMapScript = null
var floorMap = null
var roofMap = null
var gObjects = []
var gMap = null
var size = 6
var tile_width = 80
var tile_height = 36
var images = {}
var imageInfo = {}
var cameraX = 3970
var cameraY = 1425//1200
var showHexOverlay = false
var showCoordinates = false
var showPath = true
var SCREEN_WIDTH = 800, SCREEN_HEIGHT = 600
var HEX_GRID_SIZE = 200 // hex grid is 200x200
var currentElevation = 0
var doLoadScripts = true // should we load scripts?
var doUpdateCritters = true // should we give critters heartbeats?
var doTimedEvents = true // should we handle registered timed events?
var gameTickTime = 0 // in Fallout 2 ticks (elapsed seconds * 10)
var lastGameTick = 0
var combat = null
var inCombat = false

var player = {position: {x: 94, y: 109}, orientation: 2, frame: 0,
              art: "art/critters/HMJMPSAA", isPlayer: true, anim: "idle", lastFrameTime: 0,
              path: null, animCallback: null}
player.toString = function() { return "The Dude" }

var animInfo = {"idle": {type: "static"},
                "shoot": {type: "static"},
                "weapon-reload": {type: "static"},
                "walk": {type: "move"},
                "static-idle": {type: "static"},
                "run": {type: "move"}}

var showFloor = true
var showRoof = true
var showObjects = true

// todo: these will go in a separate utilities file
function toTileNum(position) {
	return position.y * 200 + position.x
}

function fromTileNum(tile) {
	return {x: tile % 200, y: Math.floor(tile / 200)}
}

function tileToScreen(x, y) {
	x = 99 - x // this algorithm expects x to be reversed
	var sx = 4752 + (32 * y) - (48 * x)
	var sy = (24 * y) + (12 * x)

   return {x: sx, y: sy}
}

function tileFromScreen(x, y) {
	var off_x = -4800 + x
	var off_y = y
	var xx = off_x - off_y * 4 / 3
	var tx = xx / 64

	if (xx >= 0) tx++
	tx = -tx
	var yy = off_y + off_x / 4
	var ty = yy / 32
	if (yy < 0) ty--

	return {x: 99 - Math.round(tx), y: Math.round(ty)}
}

function hexToScreen(x, y) {
	var sx = 4816 - ((((x + 1) >> 1) << 5) + ((x >> 1) << 4) - (y << 4))
	var sy = ((12 * (x >> 1)) + (y * 12)) + 11

	return {x: sx, y: sy}
}

function hexFromScreen(x, y) {
	var x0 = 4800
	var y0 = 0
	var nx, ny

	if (x - x0 < 0)
		nx = (x - x0 + 1) / 16 - 1
	else
		nx = (x - x0) / 16

	if (y - y0 < 0)
		ny = (y - y0 + 1) / 12 - 1
	else
		ny = (y - y0) / 12

	if (Math.abs(nx) % 2 != Math.abs(ny) % 2)
		nx--;

	var xhBase = x0 + 16 * nx
	var yhBase = y0 + 12 * ny

	var hx = (4 * (yhBase - y0) - 3 * (xhBase - x0)) / 96
	var hy = (yhBase - y0) / 12 - hx / 2

	var dx = x - xhBase
	var dy = y - yhBase

	switch(dy)
	{
	  case 0:
	     if (dx < 12)
	     {
	    hy--;
	    break;
	 }
	 if (dx > 18)
	     {
	    if (hx % 2 == 1)
	       hy--;
	        hx--;
	        break;
	     }

	  case 1:
	     if (dx < 8)
	     {
	    hx--;
	    break;
	 }
	 if (dx > 23)
	     {
	    if (hx % 2 == 1)
	       hy--;
	    hx--;
	    break;
	 }

	  case 2:
	 if (dx < 4)
	     {
	    hy--;
	    break;
	 }
	     if (dx > 28)
	     {
	    if (hx % 2 == 1)
	       hy--;
	        hx--;
	    break;
	 }
	  default:
	     break;
	}


	return {x: Math.round(hx), y: Math.round(hy)}
}

function hexNeighbors(position) {
	var neighbors = []
	var x = position.x
	var y = position.y

	function n(x, y) {
		neighbors.push({x: x, y: y})
	}

	if(x % 2 === 0) {
	  n(x-1,y)
	  n(x-1,y+1)
	  n(x,y+1)
	  n(x+1,y+1)
	  n(x+1,y)
	  n(x,y-1)
	} else{
	  n(x-1,y-1)
	  n(x-1,y)
	  n(x,y+1)
	  n(x+1,y)
	  n(x+1,y-1)
	  n(x,y-1)
	}

	return neighbors
}

function hexInDirection(position, dir) {
	return hexNeighbors(position)[dir]
}

function directionOfDelta(xa, ya, xb, yb) {
	var neighbors = hexNeighbors({x: xa, y: ya})
	for(var i = 0; i < neighbors.length; i++) {
		if(neighbors[i].x === xb && neighbors[i].y === yb)
			return i
	}

	return null
}

function hexDistance(a, b) {
	var dx = a.x - b.x
	var dy = a.y - b.y
	return Math.sqrt(dx*dx + dy*dy)
}

var hexOverlay = null
var cursor = {x: 10, y: 10}

/*function forEachScriptableObject(f, isLoaded) {
	for(var i = 0; i < gObjects.length; i++) {
		if(gObjects[i].script !== undefined && (!isLoaded || gObjects[i]._script !== undefined))
			f(gObjects[i])
	}
}*/

function loadObjectScripts(objects) {
	var goodScripts = {} // cache scripts that don't load
	for(var i = 0; i < objects.length; i++) {
		var scriptName = objects[i].script
		if(scriptName === undefined || objects[i]._script !== undefined) continue
		if(goodScripts[scriptName] === false) continue

		console.log("loading " + scriptName + " for " + objects[i].art + " (" + objects[i].type + ")" +
			" @ " + objects[i].position.x + ", " + objects[i].position.y)
		var script = scriptingEngine.loadScript(scriptName)
		if(script === null) {
			console.log("load script failed for " + scriptName)
			goodScripts[scriptName] = false
			continue
		} else {
			objects[i]._script = script
		}
	}
}

function changeElevation(level, updateScripts) {
	currentElevation = level
	floorMap = gMap[level]["tiles"]["floor"]
	roofMap  = gMap[level]["tiles"]["roof"]
	gObjects = gMap[level]["objects"]

	if(updateScripts !== false) {
		loadObjectScripts(gObjects)
		scriptingEngine.updateMap(gMapScript, gObjects, currentElevation)
	}
}

heart.preload = function() {
	function load(file) {
		heart.graphics.newImage(file+".png", function(r) { images[file] = r; })
	}

	$.ajaxSetup({async: false})

	$.get(MAP_NAME + ".images.json", function(images) {
		for(var i = 0; i < images.length; i++)
			load(images[i])
		console.log("loaded " + images.length + " tiles")
	}, "json")

	$.get(MAP_NAME + ".offsets.play.json", function(offsets) {
		imageInfo = offsets
	}, "json")

	heart.graphics.newImage("hex_outline.png", function(r) { hexOverlay = r })
}

heart.load = function() {
	heart.attach("cnv");
	$.get(MAP_NAME+".json", function(map) {
		gMap = map

		if(doLoadScripts === true) {
			scriptingEngine.init(player, MAP_NAME)
			gMapScript = scriptingEngine.loadScript(MAP_NAME)

			changeElevation(0, false)
			loadObjectScripts(gObjects)
			scriptingEngine.enterMap(gMapScript, gObjects, 0)
			scriptingEngine.updateMap(gMapScript, gObjects, currentElevation)
		}

		// todo: is map_enter_p_proc called on elevation change?
		console.log("loaded (" + map.length + " levels, level 0: " + floorMap.length + " tiles, " + gObjects.length + " objects on elevation)")
		//scriptingEngine.updateMap(gMapScript, gObjects, currentElevation)
	}, "json")

	// for testing
	var a = gObjects[1175]
	var b = gObjects[1260]
	gObjects = [a, b]
	//critterWalkTo(a, {x: 103, y: 113})
}

heart.keydown = function(k) {
	var mousePos = heart.mouse.getPosition()
	var mouseHex = hexFromScreen(mousePos[0] + cameraX, mousePos[1] + cameraY)

	if(k == 'down') cameraY += 15
	if(k == 'right') cameraX += 15
	if(k == 'left') cameraX -= 15
	if(k == 'up') cameraY -= 15
	if(k == 'q') { if(currentElevation-1 >= 0) changeElevation(currentElevation-1) }
	if(k == 'e') { if(currentElevation+1 < gMap.length) changeElevation(currentElevation+1) }
	if(k == 'r') { showRoof = !showRoof }
	if(k == 'f') { showFloor = !showFloor }
	if(k == 'o') { showObjects = !showObjects }
	if(k == 't') {
		for(var i = 0; i < gObjects.length; i++) {
			if(gObjects[i].position.x === mouseHex.x && gObjects[i].position.y === mouseHex.y) {
				console.log("object at index " + i)
				if(gObjects[i]._script && gObjects[i]._script.talk_p_proc !== undefined) {
					console.log("calling talk proc")
					gObjects[i]._script.talk_p_proc()
				}
				break
			}
		}
	}
	if(k == 'i') {
		for(var i = 0; i < gObjects.length; i++) {
			if(gObjects[i].position.x === mouseHex.x && gObjects[i].position.y === mouseHex.y) {
				var hasScripts = (gObjects[i].script !== undefined ? ("yes (" + gObjects[i].script + ")") : "no") + " " + (gObjects[i]._script === undefined ? "and is NOT loaded" : "and is loaded")
				console.log("object is at index " + i + ", has scripts? " + hasScripts)
				break
			}
		}
	}
	if(k == 'p') {
		player.frame++
		if(player.frame == 8) player.frame = 0
	}
	if(k == 'm') {
		critterWalkTo(player, mouseHex)
	}
	if(k == 'r') {
		critterWalkTo(player, mouseHex, true)
	}
	if(k == 'g') {
		critterStaticAnim(player, "shoot", function() {
			critterStaticAnim(player, "weapon-reload")
		})
	}

	if(k == 'w') {
		for(var i = 0; i < gObjects.length; i++) {
			if(gObjects[i]._script !== undefined && gObjects[i]._script.timed_event_p_proc !== undefined) {
				console.log("calling timed_event_p_proc(1) on " + gObjects[i].script)
				scriptingEngine.timedEvent(gObjects[i]._script, 1)
			}
		}
	}
	if(k == 'c') {
		if(inCombat === true) {
			console.log("[TURN]")
			combat.nextTurn()
		}
		else {
			console.log("[COMBAT BEGIN]")
			inCombat = true
			combat = new Combat(gObjects, player)
			combat.nextTurn()
		}
	}
}

function critterGetAnim(obj, anim) {
	var base = obj.art.slice(0, -2)
	switch(anim) {
		case "idle": return base + "AA"
		case "walk": return base + "AB"
		case "run":  return base + "AT"
		case "shoot": return base + "JJ"
		case "weapon-reload": return base + "JA"
		case "static-idle": return base + "AA"
		default: throw "Unknown animation: " + anim
	}
}

function getAnimDistance(art) {
	var info = imageInfo[art]
	if(info === undefined)
		throw "no image info for " + art

	var firstShift = info.frameOffsets[0][0].ox
	var lastShift = info.frameOffsets[1][info.numFrames-1].ox

	// distance = (shift x of last frame) - (shift x of first frame(?) + 16) / 32
	return Math.floor((lastShift - firstShift + 16) / 32)
}

function critterWalkTo(obj, target, running, callback) {
	// pathfind and set walking to target
	var path = recalcPath(obj.position, target)
	if(path.length === 0) {
		console.log("not a valid path")
		return false
	}
	obj.path = {path: path, index: 0, target: null, seqLength: null, distance: null}
	obj.anim = (running === true) ? "run" : "walk"
	obj.art = critterGetAnim(obj, obj.anim)
	obj.animCallback = (callback !== undefined) ? callback : (function() { critterStopWalking(obj) })
	obj.frame = 0
	obj.lastFrameTime = 0
	critterAdvancePath(obj)
}

function critterStaticAnim(obj, anim, callback) {
	obj.art = critterGetAnim(obj, anim)
	obj.frame = 0
	obj.lastFrameTime = 0
	obj.anim = anim
	obj.animCallback = (callback !== undefined) ? callback : (function() { critterStopWalking(obj) })
}

function critterStopWalking(obj) {
	obj.path = null
	obj.anim = "idle"
	obj.frame = 0
	obj.art = critterGetAnim(obj, "idle")
	obj.animCallback = null
}

function recalcPath(start, goal) {
	var matrix = new Array(HEX_GRID_SIZE)

	for(var y = 0; y < HEX_GRID_SIZE; y++)
		matrix[y] = new Array(HEX_GRID_SIZE)

	for(var i = 0; i < gObjects.length; i++) {
		var obj = gObjects[i]
		matrix[obj.position.y][obj.position.x] = 1
	}

	var grid = new PF.Grid(HEX_GRID_SIZE, HEX_GRID_SIZE, matrix)
	var finder = new PF.AStarFinder()
	var path = finder.findPath(start.x, start.y, goal.x, goal.y, grid)
	return path
}

function longestSequenceWithoutTurning(start, path, index) {
	// todo: make logic less complex
	var firstDir = directionOfDelta(start.x, start.y, path[index][0], path[index][1])
	if(index+1 >= path.length)
		return {seq: 1, lastPosition: {x: path[index][0], y: path[index][1]}, firstDirection: firstDir}

	var pos = path[index]
	var dir = firstDir
	var n = 1
	for(var i = index+1; i < path.length; i++) {
		//console.log("i " + i)
		var deltaDir = directionOfDelta(pos[0], pos[1], path[i][0], path[i][1])
		//console.log("deltaDir: " + deltaDir)
			         
		if(deltaDir !== dir) {
			//console.log("bad deltaDir: " + deltaDir)
			return {seq: n, lastPosition: {x: path[i-1][0], y: path[i-1][1]}, firstDirection: firstDir}
		}
		n++
		pos = path[i]
	}

	return {seq: n, lastPosition: {x: pos[0], y: pos[1]}, firstDirection: firstDir}
}

function critterAdvancePath(obj) {
	if(obj.path.seqLength !== undefined && obj.path.seqLength !== null)
		obj.path.index += obj.path.seqLength
	else
		obj.path.index++

	if(obj.path.index >= obj.path.path.length)
		return false
	//console.log("advancing to path index " + obj.path.index)
	var seq = longestSequenceWithoutTurning(obj.position, obj.path.path, obj.path.index)
	//console.log("longest seq: " + JSON.stringify(seq))

	obj.orientation = seq.firstDirection
	obj.path.target = seq.lastPosition
	obj.path.seqLength = seq.seq
	obj.path.distance = seq.seq
	return true
}

function critterUpdateStaticAnimation(obj) {
	var time = heart.timer.getTime()
	var fps = 8 // todo: get FPS from image info

	if(time - obj.lastFrameTime >= 1000/fps) {
		obj.frame++
		obj.lastFrameTime = time

		if(obj.frame === imageInfo[obj.art].numFrames) {
			// animation is done
			// todo: some sort of callback or action when completed?
			if(obj.animCallback)
				obj.animCallback()
		}
	}
}

function critterUpdateAnimation(obj) {
	if(obj.anim === undefined || obj.anim === "idle") return
	if(animInfo[obj.anim].type === "static") return critterUpdateStaticAnimation(obj)

	var time = heart.timer.getTime()
	var fps = 10 // todo: get FPS from image info
	var targetScreen = hexToScreen(obj.path.target.x, obj.path.target.y)
	var moveDistance = getAnimDistance(obj.art)
	var tilePerFrame = Math.floor(imageInfo[obj.art].numFrames / moveDistance)

	if(time - obj.lastFrameTime >= 1000/fps) {
		// advance frame
		obj.frame++
		obj.lastFrameTime = time

		if(obj.frame === tilePerFrame && obj.path.distance === 1) { // half walk, one tile
			obj.frame = 0
			var h = hexInDirection(obj.position, obj.orientation)
			obj.position = h
			obj.path.distance -= 1
		}
		else if(obj.frame === tilePerFrame /* *2 */) { // full walk, 2+ tiles
			obj.frame = 0
			var h = hexInDirection(obj.position, obj.orientation)
			var h2 = hexInDirection(h, obj.orientation)
			obj.position = h2
			obj.path.distance -= 2
		}

		if(obj.position.x === obj.path.target.x && obj.position.y === obj.path.target.y) {
			// reached target
			console.log("target reached")
			if(critterAdvancePath(obj) === false)
				if(obj.animCallback)
					obj.animCallback()
		}
	}
}

heart.update = function() {
	var time = heart.timer.getTime()

	if(time - lastGameTick >= 1000/10) { // 10 Hz game tick
		lastGameTick = time
		gameTickTime++
		//console.log("tick: " + gameTickTime)

		if(doTimedEvents === true && inCombat !== true) {
			// check and update timed events
			var timedEvents = scriptingEngine.timeEventList
			for(var i = 0; i < timedEvents.length; i++) {
				timedEvents[i].ticks--
				if(timedEvents[i].ticks <= 0) {
					console.log("timed event triggered")
					timedEvents[i].fn()
					timedEvents.splice(i--, 1)
				}
			}
		}

		critterUpdateAnimation(player)

		for(var i = 0; i < gObjects.length; i++) {
			if(gObjects[i].type === "critter") {
				if(doUpdateCritters === true && inCombat !== true && gObjects[i]._script !== undefined)
					scriptingEngine.updateCritter(gObjects[i]._script)
				critterUpdateAnimation(gObjects[i])
			}
		}
	}
}

function drawTileMap(matrix, offsetY) {
	for(var i = 0; i < matrix.length; i++) {
		for(var j = 0; j < matrix[0].length; j++) {
			var tile = matrix[j][i]
			if(tile === "grid000") continue;
			var img = "art/tiles/" + tile

			if(images[img] !== undefined) {
				var scr = tileToScreen(i, j)
				scr.y += offsetY
				if(scr.x+tile_width < cameraX || scr.y+tile_height < cameraY ||
				   scr.x >= cameraX+SCREEN_WIDTH || scr.y >= cameraY+SCREEN_HEIGHT)
					continue
				heart.graphics.draw(images[img], scr.x - cameraX, scr.y - cameraY)
			}
		}
	}
}

heart.draw = function() {
	heart.graphics.setColor(255, 255, 255)

	var mousePos = heart.mouse.getPosition()
	var mouseHex = hexFromScreen(mousePos[0] + cameraX, mousePos[1] + cameraY)
	var mouseTile = tileFromScreen(mousePos[0] + cameraX, mousePos[1] + cameraY)

	// draw tile grids
	if(showFloor && floorMap !== null)
		drawTileMap(floorMap, 0);

	// draw hex grid overlay
	if(showHexOverlay || showCoordinates) {
		for(var y = 0; y < HEX_GRID_SIZE; y++) {
			for(var x = 0; x < HEX_GRID_SIZE; x++) {
				var scr = hexToScreen(x, y)
				heart.graphics.draw(hexOverlay, scr.x - 16 - cameraX, scr.y - 12 - cameraY)
				if(showCoordinates) {
					heart.graphics.print(x + "," + y, scr.x - 3 - cameraX, scr.y - 3 - cameraY)
				}
				if(!showCoordinates && (x === mouseHex.x && y === mouseHex.y)) {
					heart.graphics.print("m", scr.x - 3 - cameraX, scr.y - 3 - cameraY)
				}
			}
		}
	} else {
		var scr = hexToScreen(mouseHex.x, mouseHex.y)
		heart.graphics.draw(hexOverlay, scr.x - 16 - cameraX, scr.y - 12 - cameraY)

		if(showPath === true && player.path !== null) {
			for(var i = 0; i < player.path.path.length; i++) {
				var scr = hexToScreen(player.path.path[i][0], player.path.path[i][1])
				heart.graphics.draw(hexOverlay, scr.x - 16 - cameraX, scr.y - 12 - cameraY)
			}
		} 
	}

	// draw objects
	if(showObjects) {
		gObjects.push(player)
		for(var i = 0; i < gObjects.length; i++) {
			var obj = gObjects[i]
			var scr = hexToScreen(obj.position.x, obj.position.y)

			if(images[obj.art] === undefined)
				continue; // skip images we don't have

			var info = imageInfo[obj.art]
			if(info !== undefined /*&& info.numFrames !== 1*/) { // multi-frame object drawing
				var frameIdx = 0
				if(obj.frame !== undefined)
					frameIdx += obj.frame

				var frameInfo = info.frameOffsets[obj.orientation][frameIdx]
				var dirOffset = info.directionOffsets[obj.orientation]
				var offsetX = Math.floor(frameInfo.w / 2) - dirOffset.x - frameInfo.ox
				var offsetY = frameInfo.h - dirOffset.y - frameInfo.oy
				var scrX = scr.x - offsetX, scrY = scr.y - offsetY

				if(scrX + frameInfo.w < cameraX || scrY + frameInfo.h < cameraY ||
				   scrX >= cameraX+SCREEN_WIDTH || scrY >= cameraY+SCREEN_HEIGHT)
					continue

				heart.ctx.drawImage(images[obj.art].img,
					frameInfo.sx, 0, frameInfo.w, frameInfo.h,
					scrX - cameraX,
					scrY - cameraY,
					frameInfo.w, frameInfo.h
				)
			}
			else { // single-frame (e.g. static scenery) drawing
				// todo: find out why this is slow (might be just the width/height calls)
				// currently this codepath is not taken
				console.log("single-frame: " + obj.art)
				var w = images[obj.art].getWidth()
				var h = images[obj.art].getHeight()
				var offsetX = Math.floor(w / 2) - imageInfo[obj.art].directionOffsets[0].x
				var offsetY = h - imageInfo[obj.art].directionOffsets[0].y
				var scrX = scr.x - offsetX, scrY = scr.y - offsetY
				if(scrX + w < cameraX || scrY + h < cameraY ||
				   scrX >= cameraX+SCREEN_WIDTH || scrY >= cameraY+SCREEN_HEIGHT)
					continue
				heart.graphics.draw(images[obj.art], scrX - cameraX, scrY - cameraY)
			}

			if(obj.position.x === mouseHex.x && obj.position.y === mouseHex.y)
				heart.graphics.print("tile: " + obj.art + " offset: " + offsetX + ", " + offsetY + ", orientation: " + obj.orientation, 5, 30)
		}

		gObjects.length -= 1 // hack: to draw player
	}

	if(showRoof && roofMap !== null)
		drawTileMap(roofMap, -96);

	if(floorMap[mouseTile.y] !== undefined) {
		var tileImg = floorMap[mouseTile.y][mouseTile.x]
		heart.graphics.print("tile: " + tileImg, 5, 60)
	}

	if(inCombat === true) {
		var whose = combat.whoseTurn === -1 ? "player" : combat.critters[combat.whoseTurn].art
		heart.graphics.print("[turn " + combat.turnNum + " of " + whose + "]", SCREEN_WIDTH - 200, 15)
	}

	heart.graphics.print("mh: " + mouseHex.x + "," + mouseHex.y, 5, 15)
	heart.graphics.print("mt: " + mouseTile.x + "," + mouseTile.y, 100, 15)
}

function dialogueReply(id) {
	scriptingEngine.dialogueReply(id)
}

</script>
<style>
	body {
		font-family: sans-serif;
	}

	#dialogue {
		float: right;
		width: 30%;
		height: 60%;
		border: 1px solid black;
		visibility: hidden;
		overflow: auto;
	}
</style>
</head>
<body>

<canvas id="cnv" width="800" height="600">your browser doesn't support &lt;canvas&gt;</canvas>

<div id="dialogue"></div>

</body>
</html>