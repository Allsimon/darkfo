<!-- DarkFO
     Copyright (c) 2014 darkf
     Licensed under the terms of the zlib license
 -->

<html>
<head>
<title>DarkFO: Play!</title>
<script src="heart.js"></script>
<script src="jquery-1.11.1.min.js"></script>
<script src="util.js"></script>
<script src="geometry.js"></script>
<script src="scripting.js"></script>
<script src="combat.js"></script>
<script src="object.js"></script>
<script src="critter.js"></script>
<script src="pathfinding-browser.js"></script>
<script src="criticalEffects.js"></script>
<script src="skillDependencies.js"></script>
<script src="characterCreation.js"></script>
<script>
"use strict";

var MAP_NAME = "ENCFITE" // name of the current map
var DEBUG = false // debug mode

var gMapScript = null
var floorMap = null
var roofMap = null
var images = {}
var imageInfo = null
var gObjects = []
var gMap = null
var currentElevation = 0 // current map elevation
var hexOverlay = null
//var cursor = {x: 10, y: 10}

// position of viewport camera (will be overriden by map starts or scripts)
var cameraX = 3580
var cameraY = 1020

// geometry constants
var TILE_WIDTH = 80
var TILE_HEIGHT = 36
var HEX_GRID_SIZE = 200 // hex grid is 200x200
var SCREEN_WIDTH = 800, SCREEN_HEIGHT = 600
var SCROLL_PADDING = 20 // how far the mouse has to be from an edge to scroll
var FLOAT_MSG_DURATION = 3 // in seconds

var showHexOverlay = false // show hex grid?
var showCoordinates = false // show coordinates on hex grid?
var showPath = true // show player's path?
var showFloor = true // show floor tiles?
var showRoof = true // show roof tiles?
var showObjects = true // show objects?
var showWalls = true // show walls?

var doLoadScripts = true // should we load scripts?
var doUpdateCritters = false // should we give critters heartbeats?
var doTimedEvents = true // should we handle registered timed events?
var doCombat = true // allow combat?
var doUseWeaponModel = true // use weapon model for NPC models?
var doLoadItemInfo = true // load item information (such as inventory images)?
var doAlwaysRun = true // always run instead of walk?

var gameTickTime = 0 // in Fallout 2 ticks (elapsed seconds * 10)
var lastGameTick = 0 // real time of the last game tick
var combat = null // combat object
var inCombat = false // are we currently in combat?
var gameHasFocus = false // do we have input focus?
var lastMousePickTime = 0 // time when we last checked what's under the mouse cursor

var isLoading = true // are we currently loading a map?
var loadingAssetsLoaded = 0 // how many images we've loaded
var loadingAssetsTotal = 0 // out of this total

var proFiles = {}
var lstFiles = {}
var messageFiles = {}
var mapNames = null

var floatMessages = []

var cameraDownKey = "down"
var cameraUpKey = "up"
var cameraLeftKey = "left"
var cameraRightKey = "right"
var elevationDownKey = "q"
var elevationUpKey = "e"
var showRoofKey = "r"
var showFloorKey = "f"
var showObjectsKey = "o"
var showWallsKey = "w"
var talkToKey = "t"
var inspectKey = "i"
var moveToKey = "m"
var runToKey = "j"
var attackKey = "g"
var combatKey = "c"
var playerToTargetRaycastKey = "y"
var showTargetInventoryKey = "v"
var useKey = "u"
var killKey = "k"

// the player object
// todo: just load this from the PRO or something
var playerWeapon = {art: "art/items/uzi", frmPID: 44, pid: 9, pidID: 9,
  subtype: "weapon", amount: 1, inventory: [], type: "item", pro: {
    lightRadius: 0, frmPID: 44, extra: {
      animCode: 6, weight: 5,  materialID: 1, subType: 3, flagsExt: "'\\x00\\x00\\x00'",
      cost: 1000, APCost2: 6, APCost1: 5, rounds: 10, minDmg: 1, size: 3,
      dmgType: 0, minST: 4, soundID: "D", maxAmmo: 30, attackMode: 118, maxRange2: 20,
      maxRange1: 25, invFRM: 117440514, maxDmg: 12, ammoPID: 29, critFail: 2, scriptID: -1,
      projPID: -1, caliber: 8},
    textID: 900, pid: 9, frmType: 0, flags: 8, lightIntensity: 0, type: 0},
  name: "10mm SMG",
  invArt: "art/inven/uzi"}
playerWeapon.weapon = new Weapon(playerWeapon)

var player = playerInit()
			/*{position: {x: 94, y: 109}, orientation: 2, frame: 0,
              art: "art/critters/hmjmpsaa", isPlayer: true, anim: "idle", lastFrameTime: 0,
              path: null, animCallback: null, type: "critter",
          	  baseStats: {STR: 8, PER: 5, END: 5, CHR: 6, INT: 5, AGI: 6, LUK: 5, HP: 100},
          	  bonusStats: {STR: 0, PER: 0, END: 0, CHR: 0, INT: 0, AGI: 0, LUK: 0, HP: 0},
          	  leftHand: playerWeapon, rightHand: null, weapon: null, armor: null,
          	  dead: false, name: "Player", gender: "male",
          	  skills: {"Repair": 25, "Big Guns": 25, "Outdoorsman": 25, "Traps": 25, "Barter": 25,
          	  		   "Melee": 25, "Throwing": 25, "Steal": 25, "Doctor": 25, "Sneak": 25,
          	  		   "Unarmed": 25, "Speech": 25, "First Aid": 25, "Lockpick": 25, "Science": 25,
          	  		   "Gambling": 25, "Small Guns": 50, "Energy Weapons": 50},
          	  inventory: [
          	  	{type: "misc", name: "Money", pid: 41, pidID: 41, amount: 1337, pro: {textID: 4100, extra: {cost: 1}, invFRM: 117440552}, invArt: 'art/inven/cap2'}
          	  ]}*/

function repr(obj) { return JSON.stringify(obj, null, 2) }

function loadMessage(name) {
	var msg = getFileText("data/text/english/game/" + name + ".msg")
	if(messageFiles[name] === undefined)
		messageFiles[name] = {}

	// parse message file
	var lines = msg.split(/\r|\n/)

	// preprocess and merge lines
	for(var i = 0; i < lines.length; i++) {
		// comments/blanks
		if(lines[i][0] === '#' || lines[i].trim() === '') {
			lines.splice(i--, 1)
			continue
		}

		// probably a continuation -- merge it with the last line
		if(lines[i][0] !== '{') {
			lines[i-1] += lines[i]
			lines.splice(i--, 1)
			continue
		}
	}

	for(var i = 0; i < lines.length; i++) {
		// e.g. {100}{}{You have entered a dark cave in the side of a mountain.}
		var m = lines[i].match(/\{(\d+)\}\{.*\}\{(.*)\}/)
		if(m === null)
			throw "message parsing: not a valid line: " + lines[i]
		// HACK: replace unicode replacement character with an apostrophe (because the Web sucks at character encodings)
		messageFiles[name][m[1]] = m[2].replace(/\ufffd/g, "'")
	}
}

function getMessage(name, id) {
	if(messageFiles[name] !== undefined && messageFiles[name][id] !== undefined)
		return messageFiles[name][id]
	else {
		loadMessage(name)
		if(messageFiles[name] !== undefined && messageFiles[name][id] !== undefined)
			return messageFiles[name][id]
		else null
	}
}

function loadLst(lst) {
	return getFileText("data/" + lst + ".lst").split('\n')
}

function getLstId(lst, id) {
	if(lstFiles[lst] === undefined)
		lstFiles[lst] = loadLst(lst)
	if(lstFiles[lst] === undefined)
		return null

	return lstFiles[lst][id]
}

function lazyLoadImage(art, callback, isHeartImg) {
	var img = new Image()
	img.src = art + '.png'
	img.onload = function() {
		images[art] = new heart.HeartImage(img)
		if(callback)
			callback(isHeartImg ? images[art] : img)
	}
}

function pad(n, width, z) {
  z = z || '0';
  n = n + '';
  return n.length >= width ? n : new Array(width - n.length + 1).join(z) + n;
}

function getPROType(pid) {
	var map = {0: 'items', 1: 'critters', 2: 'scenery', 3: 'walls', 4: 'tiles', 5: 'misc'}
	return map[(pid >> 24) & 0xff]
}

function loadPRO(pid, pidID) {
	if(proFiles[pid] !== undefined)
		return proFiles[pid] // todo: clone?

	// use the proto/ .lst files to look up proto
	var type = getPROType(pid)
	var lsts = {"items": "proto/items/items", "critters": "proto/critters/critters",
                "scenery": "proto/scenery/scenery", "misc": "proto/misc/misc"}
	var id = lsts[type] ? getLstId(lsts[type], pidID - 1) : pidID
	var path = lsts[type] ? id : (pad(id, 8) + '.pro')

	var pro = getFileJSON('proto/' + type + '/' + path + '.json')
	proFiles[pid] = pro
	return pro
}

function getPROTypeName(type) {
	// singular
	var map = {0: 'item', 1: 'critter', 2: 'scenery', 3: 'wall', 4: 'tile', 5: 'misc'}
	return map[type]
}

function getPROSubTypeName(type) {
	var map = {0: 'armor', 1: 'container', 2: 'drug', 3: 'weapon', 4: 'ammo', 5: 'misc', 6: 'key'}
	return map[type]
}

function makePID(type, pid) {
	return (type << 24) | pid
}

function createObjectWithPID(pid, sid) {
	var pidType = (pid >> 24) & 0xff
	var pidID = pid & 0xffff
	var pro = loadPRO(pid, pidID)
	var obj = {type: getPROTypeName(pidType), pro: pro, pid: pid, pidID: pidID, amount: 1, position: {x: -1, y: -1}, inventory: []}
	if(pidType === 0) { // item
		obj.subtype = getPROSubTypeName(pro.extra.subtype)
		obj.name = getMessage("pro_item", pro.textID)

		var invPID = pro.extra.invFRM & 0xffff
		console.log("invPID: " + invPID + ", also: " + pid)
		if(invPID !== 0xffff)
			obj.invArt = "art/inven/" + getLstId("art/inven/inven", invPID).split('.')[0]
	}

	if(obj.pro !== undefined)
		obj.art = lookupArt(makePID(obj.pro.frmType, obj.pro.frmPID))
	else
		obj.art = "art/items/RESERVED"

	if(pidType === 1) // critter
		initCritters([obj]) // initialize the critter

	var objectScriptID = -1
	if(obj.pro !== undefined) {
		if(obj.pro.extra !== undefined && obj.pro.extra.scriptID !== undefined)
			objectScriptID = obj.pro.extra.scriptID
		else if(obj.pro.scriptID !== undefined)
			objectScriptID = obj.pro.scriptID
	}

	if(obj.pro !== undefined && obj.pro.extra !== undefined &&
	   sid !== undefined && objectScriptID != sid) {
		//console.log("!!! createObjectWithPID: need to change script ID (" + objectScriptID +
		//	" to " + sid + ")")
		console.log("createObjectWithPID: sid = " + sid)
		var scriptName = lookupScriptName(sid)
		console.log("createObjectWithPID: loading " + scriptName + " (" + sid + ")")
		var script = scriptingEngine.loadScript(scriptName)
		if(script === null) {
			console.log("createObjectWithPID: load script failed for " + scriptName + " ( " + sid + ")")
		} else {
			obj._script = script
			scriptingEngine.initScript(obj._script, obj)
			// TODO: do we enterMap/etc?
		}
	}

	return obj
}

function getCritterArtPath(frmPID) {
	console.log("FRM PID: " + frmPID)
	var idx = (frmPID & 0x00000fff)
	var id1 = (frmPID & 0x0000f000) >> 12
	var id2 = (frmPID & 0x00ff0000) >> 16
	var id3 = (frmPID & 0x70000000) >> 28

	if (id2 == 0x1b || id2 == 0x1d ||
			id2 == 0x1e || id2 == 0x37 ||
			id2 == 0x39 || id2 == 0x3a ||
			id2 == 0x21 || id2 == 0x40) {
		throw "reindex(?)"
	}

	var path = "art/critters/" + getLstId("art/critters/critters", idx).split(',')[0].toLowerCase()

	if(id1 >= 0x0b)
		throw "?"

	if(id2 >= 0x26 && id2 <= 0x2f)
		throw ("0x26 and 0x2f")
	else if(id2 === 0x24)
		path += "ch"
	else if(id2 === 0x25)
		path += "cj"
	else if(id2 >= 0x30)
		path += 'r' + String.fromCharCode(id2 + 0x31)
	else if(id2 >= 0x14)
		throw "0x14"
	else if (id2 === 0x12) {
		throw "0x12"
		if(id1 === 0x01)
			path += "dm"
		else if(id1 === 0x04)
			path += "gm"
		else
			path += "as"
	}
	else if(id2 === 0x0d)
		throw "0x0d"
	else {
		if(id2 <= 1 && id1 > 0) {
			console.log("ID1: " + id1)
			path += String.fromCharCode(id1 + 'c'.charCodeAt(0))
		}
		else
			path += 'a'
		path += String.fromCharCode(id2 + 'a'.charCodeAt(0))
	}

	return path
}

function lookupArt(frmPID) {
	var type = getPROType(frmPID)
	var pidID = frmPID & 0xffff

    if(type === "critters")
    	return getCritterArtPath(frmPID)

	var lsts = {"items": "art/items/items",
                "scenery": "art/scenery/scenery", "misc": "art/misc/misc"}
	var path = "art/" + type + "/" + getLstId(lsts[type], pidID).split('.')[0]

	console.log("LOOKUP ART: " + path)
	return path.toLowerCase()
}

function lookupScriptName(scriptID) {
	return getLstId("scripts/scripts", scriptID - 1).split('.')[0].toLowerCase()
}

function dropObject(source, obj) {
	// drop inventory object obj from source
	var idx = -1
	for(var i = 0; i < source.inventory.length; i++) {
		if(source.inventory[i].pid === obj.pid) {
			idx = i
			break
		}
	}
	if(idx === -1) throw "dropObject: couldn't find object"

	obj.position.x = source.position.x
	obj.position.y = source.position.y
	source.inventory.splice(idx, 1) // remove from source
	gObjects.push(obj) // add to objects
}

// Draws a line between a and b, returning the first object hit
function hexLinecast(a, b) {
	var line = hexLine(a, b)
	if(line === null)
		return null
	for(var i = 0; i < line.length; i++) {
		// todo: we could optimize this by only
		// checking in a certain radius of `a`
		var obj = objectsAtPosition(line[i])
		if(obj.length !== 0)
			return obj[0]
	}
	return null
}

function objectsAtPosition(position) {
	var ret = []
	for(var i = 0; i < gObjects.length; i++) {
		if(gObjects[i].position.x === position.x && gObjects[i].position.y === position.y) {
			ret.push(gObjects[i])
		}
	}
	return ret
}

function critterAtPosition(position) {
	var objects = objectsAtPosition(position)
	for(var i = 0; i < objects.length; i++) {
		if(objects[i].type === "critter")
			return objects[i]
	}
	return null
}

function loadObjectScripts(objects) {
	var goodScripts = {} // cache scripts that don't load
	for(var i = 0; i < objects.length; i++) {
		var scriptName = objects[i].script
		if(scriptName === undefined || objects[i]._script !== undefined) continue
		if(goodScripts[scriptName] === false) continue

		console.log("loading " + scriptName + " for " + objects[i].art + " (" + objects[i].type + ")" +
			" @ " + objects[i].position.x + ", " + objects[i].position.y)
		var script = scriptingEngine.loadScript(scriptName)
		if(script === null) {
			console.log("load script failed for " + scriptName)
			goodScripts[scriptName] = false
			continue
		} else {
			objects[i]._script = script
			scriptingEngine.initScript(objects[i]._script, objects[i])
		}
	}
}

function changeElevation(level, updateScripts) {
	currentElevation = level
	floorMap = gMap.levels[level]["tiles"]["floor"]
	roofMap  = gMap.levels[level]["tiles"]["roof"]
	gObjects = gMap.levels[level]["objects"]

	if(updateScripts !== false) {
		loadObjectScripts(gObjects)
		scriptingEngine.enterMap(gMapScript, gObjects, currentElevation, gMap.mapID, false) // ?
		scriptingEngine.updateMap(gMapScript, gObjects, currentElevation)
	}

	centerCamera(player.position)
}

// Initialize various objects, such as items.
function initObjects(objects) {
	for(var i = 0; i < objects.length; i++) {
		var obj = objects[i]
		if(obj.type === "critter") {
			initObjects(obj.inventory)
			continue // critters are handled separately
		}

		if(obj.inventory !== undefined)
			initObjects(obj.inventory) // containers, etc

		if(obj.type === "item") { // load item inventory art
			obj.pro = loadPRO(obj.pid, obj.pidID)
			if(obj.pro === null) continue

			obj.name = getMessage("pro_item", obj.pro.textID)

			var invPID = obj.pro.extra.invFRM & 0xffff
			if(invPID !== 0xffff)
				obj.invArt = "art/inven/" + getLstId("art/inven/inven", invPID).split('.')[0]
		}
		else if(obj.type === "scenery") {
			obj.pro = loadPRO(obj.pid, obj.pidID)
			if(obj.pro === null) continue
			var subtypeMap = {0: "door", 1: "stairs", 2: "elevator", 3: "ladder",
							  4: "ladder", 5: "generic"}
			obj.subtype = subtypeMap[obj.pro.extra.subType]

			if(obj.subtype === "door")
				obj.open = false
		}
		else if(obj.type === "wall") {
			obj.pro = loadPRO(obj.pid, obj.pidID)
		}
	}
}

// Initialize critters (mainly loading inventory and .PRO files)
function initCritters(objects) {
	// load .PRO prototypes for all critters
	for(var i = 0; i < objects.length; i++) {
		var obj = objects[i]
		if(obj.type !== "critter") continue
		if(!obj.pro)
			obj.pro = loadPRO(obj.pid, obj.pidID)
		obj.stats = calcStats(obj, obj.pro)
		obj.skills = obj.pro.extra.skills
		obj.name = getMessage("pro_crit", obj.pro.textID)

		// PROs for weapons
		for(var j = 0; j < obj.inventory.length; j++) {
			var inv = obj.inventory[j]
			if(inv.pro === undefined)
				inv.pro = loadPRO(inv.pid, inv.pidID)

			if(inv.subtype === "weapon") {
				if(obj.leftHand === undefined) {
					inv.weapon = new Weapon(inv)
					if(inv.weapon.canEquip(obj))
						obj.leftHand = inv
				}
				else if(obj.rightHand === undefined) {
					inv.weapon = new Weapon(inv)
					if(inv.weapon.canEquip(obj))
						obj.rightHand = inv
				}
				//console.log("left: " + obj.leftHand + " | right: " + obj.rightHand)
			}
		}

		// default to punches
		if(!obj.leftHand)
			obj.leftHand = {type: "item", subtype: "weapon", weapon: new Weapon("punch")}
		if(!obj.rightHand)
			obj.rightHand = {type: "item", subtype: "weapon", weapon: new Weapon("punch")}

		// set them in their proper idle state for the weapon
		obj.art = critterGetAnim(obj, "idle")
	}
}

function centerCamera(around) {
	var scr = hexToScreen(around.x, around.y)
	cameraX = Math.max(0, scr.x - SCREEN_WIDTH/2)
	cameraY = Math.max(0, scr.y - SCREEN_HEIGHT/2)
}

function loadMap(mapName, startingPosition, startingElevation) {
	function load(file, callback) {
		if(images[file] !== undefined) return // don't load more than once
		loadingAssetsTotal++
		heart.graphics.newImage(file+".png", function(r) {
			images[file] = r
			loadingAssetsLoaded++
			if(callback) callback(r)
		})
	}

	isLoading = true
	loadingAssetsTotal = 1 // this will remain +1 until we load the map, preventing it from exiting early
	loadingAssetsLoaded = 0

	// clear any previous objects/events
	gMap = null
	gObjects = null
	gMapScript = null
	scriptingEngine.reset(player, mapName)

	// reset player animation status
	player.path = null
	player.frame = 0
	player.anim = "idle"

	console.log("loading map " + mapName)

	var mapImages = getFileJSON("maps/" + mapName + ".images.json")
	for(var i = 0; i < mapImages.length; i++)
		load(mapImages[i])
	console.log("loading " + mapImages.length + " images")

	if(imageInfo === null)
		imageInfo = getFileJSON("art/imageMap.json")

	var map = getFileJSON("maps/"+mapName+".json")
	gMap = map
	var elevation = (startingElevation !== undefined) ? startingElevation : 0

	for(var level = 0; level < gMap.levels.length; level++) {
		if(doLoadItemInfo !== false)
			initObjects(gMap.levels[level]["objects"])
		initCritters(gMap.levels[level]["objects"])
	}

	if(doLoadScripts === true) {
		scriptingEngine.init(player, mapName)
		gMapScript = scriptingEngine.loadScript(mapName)

		// warp to the default position (may be overridden by map script)
		player.position = startingPosition || gMap.startPosition
		player.orientation = gMap.startOrientation

		changeElevation(elevation, false)
		loadObjectScripts(gObjects)
		scriptingEngine.enterMap(gMapScript, gObjects, elevation, gMap.mapID, true)
		scriptingEngine.updateMap(gMapScript, gObjects, elevation)
	}
	else changeElevation(elevation, false)

	// todo: is map_enter_p_proc called on elevation change?
	console.log("loaded (" + map.levels.length + " levels, level 0: " + floorMap.length + " tiles, " + gObjects.length + " objects on elevation)")

	// load some testing art
	load("art/critters/hmjmpsat")

	load("hex_outline", function(r) { hexOverlay = r })

	if(doCombat === true && DEBUG === true) {
		// for testing on GECKSETL
		var a = gObjects[1175]
		var b = gObjects[1260]
		gObjects = [a, b]
	}

	loadingAssetsTotal-- // we should know all of the assets we need by now
}

function lookupMapName(mapID) {
	if(mapNames !== null)
		return mapNames[mapID] || null

	// load mapNames from data/data/MAPS.TXT
	mapNames = {}
	var text = getFileText("data/data/MAPS.TXT")
	var ini = parseIni(text)
	for(var category in ini) {
		var id = category.match(/Map (\d+)/)[1]
		if(id === null) throw "MAPS.TXT: invalid category: " + category
		id = parseInt(id)
		mapNames[id] = ini[category].map_name
	}

	return mapNames[mapID] || null
}

function loadMapID(mapID, startingPosition, startingElevation) {
	var mapName = lookupMapName(mapID)
	if(mapName !== null)
		loadMap(mapName, startingPosition, startingElevation)
	else
		console.log("couldn't lookup map name for map ID " + mapID)
}

heart.load = function() {
	heart.attach("cnv")

	loadMap(MAP_NAME) // load initial map
  gObjects.push(player)

	if(doCombat === true)
		CriticalEffects.loadTable()

	$("#cnv").mouseenter(function() { gameHasFocus = true }).
	          mouseleave(function() { gameHasFocus = false })

	drawPlayerInventory()
	zsort()
}

var Mergesort = (function() {
 
  /**
   * Sorts the array by breaking it down
   * into smaller chunks.
   *
   * @param {Array} array The array to sort
   */
  function sort(array, fn) {
 
    var length = array.length,
        mid    = Math.floor(length * 0.5),
        left   = array.slice(0, mid),
        right  = array.slice(mid, length);
 
    if(length === 1) {
      return array;
    }
 
    return merge(sort(left, fn), sort(right, fn), fn);
 
  }
 
  /**
   * Merges two sublists back together.
   * Shift either left or right onto
   * the result depending on which is
   * lower (assuming both exist), and simply
   * pushes on a list if the other doesn't
   * exist.
   *
   * @param {Array} left The left hand sublist
   * @param {Array} right The right hand sublist
   */
  function merge(left, right, fn) {
 
    var result = [];
 
    while(left.length || right.length) {
 
      if(left.length && right.length) {
 
        if(fn(left[0], right[0]) === -1) {
          result.push(left.shift());
        } else {
          result.push(right.shift());
        }
 
      } else if (left.length) {
        result.push(left.shift());
      } else {
        result.push(right.shift());
      }
 
    }
 
    return result;
 
  }
 
  return {
    sort: sort
  };
 
})();

function zsort() {
	gObjects = Mergesort.sort(gObjects, function(a, b) {
		var aY = a.position.y
		var bY = b.position.y

		var aX = a.position.x
		var bX = b.position.x

		if(aY === bY) {
			if(aX < bX) return -1
			else if(aX > bX) return 1
			else if(aX === bX) return 0
		}

		if(aY < bY) return -1
		else if(aY > bY) return 1
	})
}

function drawInventory($el, obj, clickCallback) {
	$el.html("")
	for(var i = 0; i < obj.inventory.length; i++) {
		if(obj.inventory[i].invArt === undefined) { // make a guess
			var s = obj.inventory[i].art.split('/')
			var inventoryImage = 'art/inven/' + s[s.length-1]
		} else
			var inventoryImage = obj.inventory[i].invArt

		//console.log("inv img: " + inventoryImage)
		if(images[inventoryImage] === undefined)
			lazyLoadImage(inventoryImage, null, false)
		var img = $("<img>").attr("src", inventoryImage+'.png').
		          attr("width", 90).attr("height", 60) // 90x60 // 70x40
		img.attr("title", obj.inventory[i].name)
		if(clickCallback !== undefined)
			(function(invObj) {
				img.click(function(e) { clickCallback(invObj, obj, e) })
			})(obj.inventory[i])
		$el.append(img).append("x" + obj.inventory[i].amount)
	}
}

function drawPlayerInventory() {
	// draw the player inventory with click handlers for
	// using or dropping items

	drawInventory($("#playerInventory"), player, function(item, _, event) {
		if(event.shiftKey) { // shift+click -> drop item
			dropObject(player, item)
			drawPlayerInventory()
		}
		else { // click -> use item
			useObject(item, player)
		}
	})
}

function isSelectableObject(obj) {
	return obj.visible !== false && (canUseObject(obj) || obj.type === "critter")
}

heart.mousepressed = function(x, y, btn) {
	if(isLoading === true) return
	if(btn !== "l") return

	var mousePos = heart.mouse.getPosition()
	var mouseHex = hexFromScreen(mousePos[0] + cameraX, mousePos[1] + cameraY)

	// if there's an object under the cursor, use it
	var obj = getObjectUnderCursor(isSelectableObject)
	if(obj !== null) {
		if(obj.type === "critter") {
			if(obj === player) return

			if(inCombat === true && obj.dead !== true) {
				// attack a critter
				if(!combat.inPlayerTurn || objectInAnim(player)) {
					console.log("You can't do that yet.")
					return
				}

				if(player.AP.getAvailableCombatAP() < 4) {
					console.log("You don't have enough AP for that.")
					return
				}

				player.AP.subtractCombatAP(4)
				console.log("Attacking...")
				combat.attack(player, obj)
			}
			else if(obj.dead !== true && inCombat !== true &&
				obj._script && obj._script.talk_p_proc !== undefined) {
				// talk to a critter
				console.log("Talking to " + critterGetName(obj))
				scriptingEngine.talk(obj._script, obj)
			}
			else if(obj.dead === true) {
				// loot a dead body
				var drawInv = function() {
					drawInventory($("#inventory"), obj, function(selected) {
						objectSwapItem(obj, selected, player, 1)
						drawPlayerInventory()
						drawInv()
					})
				}
				drawInv()
			}
			else console.log("Cannot talk to/loot that critter")
		}
		else
			useObject(obj, player)
	}
	else // otherwise walk to the destination
		critterWalkTo(player, mouseHex, doAlwaysRun)
}

heart.keydown = function(k) {
	if(isLoading === true) return
	var mousePos = heart.mouse.getPosition()
	var mouseHex = hexFromScreen(mousePos[0] + cameraX, mousePos[1] + cameraY)

	if(k == cameraDownKey) cameraY += 15
	if(k == cameraRightKey) cameraX += 15
	if(k == cameraLeftKey) cameraX -= 15
	if(k == cameraUpKey) cameraY -= 15
	if(k == elevationDownKey) { if(currentElevation-1 >= 0) changeElevation(currentElevation-1) }
	if(k == elevationUpKey) { if(currentElevation+1 < gMap.levels.length) changeElevation(currentElevation+1) }
	if(k == showRoofKey) { showRoof = !showRoof }
	if(k == showFloorKey) { showFloor = !showFloor }
	if(k == showObjectsKey) { showObjects = !showObjects }
	if(k == showWallsKey) showWalls = !showWalls
	if(k == talkToKey) {
		for(var i = 0; i < gObjects.length; i++) {
			if(gObjects[i].position.x === mouseHex.x && gObjects[i].position.y === mouseHex.y) {
				console.log("object at index " + i)
				if(gObjects[i]._script && gObjects[i]._script.talk_p_proc !== undefined) {
					console.log("talking to " + gObjects[i].name)
					scriptingEngine.talk(gObjects[i]._script, gObjects[i])
					break
				}
			}
		}
	}
	if(k == inspectKey) {
		for(var i = 0; i < gObjects.length; i++) {
			if(gObjects[i].position.x === mouseHex.x && gObjects[i].position.y === mouseHex.y) {
				var hasScripts = (gObjects[i].script !== undefined ? ("yes (" + gObjects[i].script + ")") : "no") + " " + (gObjects[i]._script === undefined ? "and is NOT loaded" : "and is loaded")
				console.log("object is at index " + i + ", of type " + gObjects[i].type + ", has art " + gObjects[i].art + ", and has scripts? " + hasScripts)
			}
		}
	}
	if(k == moveToKey) {
		critterWalkTo(player, mouseHex)
	}
	if(k == runToKey) {
		critterWalkTo(player, mouseHex, true)
	}
	if(k == attackKey) {
		if(!inCombat || !combat.inPlayerTurn || player.anim !== "idle") {
			console.log("You can't do that yet.")
			return
		}

		if(player.AP.getAvailableCombatAP() < 4) {
			console.log("You don't have enough AP for that.")
			return
		}

		for(var i = 0; i < combat.combatants.length; i++) {
			if(combat.combatants[i].position.x === mouseHex.x && combat.combatants[i].position.y === mouseHex.y && !combat.combatants[i].dead) {
				player.AP.subtractCombatAP(4)
				console.log("Attacking...")
				combat.attack(player, combat.combatants[i])
				break
			}
		}
	}

	if(k == combatKey) {
		if(!doCombat) return
		if(inCombat === true && combat.inPlayerTurn === true) {
			console.log("[TURN]")
			combat.nextTurn()
		}
		else if(inCombat === true) {
			console.log("Wait your turn...")
		}
		else {
			console.log("[COMBAT BEGIN]")
			inCombat = true
			combat = new Combat(gObjects, player)
			combat.nextTurn()
		}
	}

	if(k == playerToTargetRaycastKey) {
		var obj = objectsAtPosition(mouseHex)[0]
		if(obj !== undefined) {
			var hit = hexLinecast(player.position, obj.position)
			console.log("hit obj: " + hit.art)
		}
	}

	if(k == showTargetInventoryKey) {
		var obj = objectsAtPosition(mouseHex)[0]
		if(obj !== undefined) {
			console.log("PID: " + obj.pid)
			console.log("inventory: " + JSON.stringify(obj.inventory))

			drawInventory($("#inventory"), obj)
		}
	}

	if(k == useKey) {
		var objs = objectsAtPosition(mouseHex)
		for(var i = 0; i < objs.length; i++) {
			useObject(objs[i])
		}
	}

	if(k == 'h')
		critterMove(player, mouseHex)

	if(k == killKey) {
		var objs = objectsAtPosition(mouseHex)
		for(var i = 0; i < objs.length; i++) {
			if(objs[i].type === "critter") {
				critterKill(objs[i], player)
				break
			}
		}
	}
}

function recalcPath(start, goal) {
	var matrix = new Array(HEX_GRID_SIZE)

	for(var y = 0; y < HEX_GRID_SIZE; y++)
		matrix[y] = new Array(HEX_GRID_SIZE)

	for(var i = 0; i < gObjects.length; i++) {
		// if there are multiple, any blocking one will block
		var obj = gObjects[i]
		matrix[obj.position.y][obj.position.x] |= objectBlocks(obj)
	}

	var grid = new PF.Grid(HEX_GRID_SIZE, HEX_GRID_SIZE, matrix)
	var finder = new PF.AStarFinder()
	var path = finder.findPath(start.x, start.y, goal.x, goal.y, grid)
	return path
}

function changeCursor(image) {
	$("#cnv").css("cursor", image)
}

function getObjectUnderCursor(p) {
	var mouse = heart.mouse.getPosition()
	mouse = {x: mouse[0] + cameraX, y: mouse[1] + cameraY}

	// reverse z-ordered search
	for(var i = gObjects.length - 1; i > 0; i--) {
		var bbox = objectBoundingBox(gObjects[i])
		if(bbox === null) continue
		if(pointInBoundingBox(mouse, bbox))
			if(p === undefined || p(gObjects[i]) === true)
				return gObjects[i]
	}

	return null
}

heart.update = function() {
	if(isLoading === true) {
		if(loadingAssetsLoaded === loadingAssetsTotal) isLoading = false
		else return
	}
	var time = heart.timer.getTime()

	if(gameHasFocus) {
		var mousePos = heart.mouse.getPosition()
		if(mousePos[0] <= SCROLL_PADDING) cameraX -= 15
		if(mousePos[0] >= SCREEN_WIDTH-SCROLL_PADDING) cameraX += 15

		if(mousePos[1] <= SCROLL_PADDING) cameraY -= 15
		if(mousePos[1] >= SCREEN_HEIGHT-SCROLL_PADDING) cameraY += 15

		if(time >= lastMousePickTime + 750) { // every .75 seconds, check the object under the cursor
			lastMousePickTime = time

			var obj = getObjectUnderCursor(isSelectableObject)
			if(obj !== null)
				changeCursor("pointer")
			else changeCursor("auto")
		}

		for(var i = 0; i < floatMessages.length; i++) {
			if(time >= floatMessages[i].startTime + 1000*FLOAT_MSG_DURATION) {
				floatMessages.splice(i--, 1)
				continue
			}
		}
	}

	var didTick = (time - lastGameTick >= 1000/10) // 10 Hz game tick
	if(didTick) {
		lastGameTick = time
		gameTickTime++

		if(doTimedEvents === true && inCombat !== true) {
			// check and update timed events
			var timedEvents = scriptingEngine.timeEventList
			for(var i = 0; i < timedEvents.length; i++) {
				if(timedEvents[i].obj &&
				   timedEvents[i].obj.dead === true) { // remove events for dead objects
				   	console.log("removing timed event for dead object")
				   	timedEvents.splice(i--, 1)
				    continue
				}

				timedEvents[i].ticks--
				if(timedEvents[i].ticks <= 0) {
					scriptingEngine.info("timed event triggered", "timer")
					timedEvents[i].fn()
					timedEvents.splice(i--, 1)
				}
			}
		}
	}

	critterUpdateAnimation(player)

	for(var i = 0; i < gObjects.length; i++) {
		if(gObjects[i].type === "critter") {
			if(didTick && doUpdateCritters && inCombat !== true && !gObjects[i].dead &&
				objectInAnim(gObjects[i]) === false && gObjects[i]._script)
				scriptingEngine.updateCritter(gObjects[i]._script, gObjects[i])
			critterUpdateAnimation(gObjects[i])
		}
		else if(gObjects[i].anim === "single" || gObjects[i].anim === "reverse")
			objectUpdateAnimation(gObjects[i])
	}
}

function drawTileMap(matrix, offsetY) {
	for(var i = 0; i < matrix.length; i++) {
		for(var j = 0; j < matrix[0].length; j++) {
			var tile = matrix[j][i]
			if(tile === "grid000") continue
			var img = "art/tiles/" + tile

			if(images[img] !== undefined) {
				var scr = tileToScreen(i, j)
				scr.y += offsetY
				if(scr.x+TILE_WIDTH < cameraX || scr.y+TILE_HEIGHT < cameraY ||
				   scr.x >= cameraX+SCREEN_WIDTH || scr.y >= cameraY+SCREEN_HEIGHT)
					continue
				heart.graphics.draw(images[img], scr.x - cameraX, scr.y - cameraY)
			}
		}
	}
}

// get an object's bounding box in screen-space (note: not camera-space)
function objectBoundingBox(obj) {
	var scr = hexToScreen(obj.position.x, obj.position.y)

	if(images[obj.art] === undefined) // no art
		return null

	var info = imageInfo[obj.art]
	if(info === undefined)
		throw "No image map info for: " + obj.art

	var frameIdx = 0
	if(obj.frame !== undefined)
		frameIdx += obj.frame

	if(!(obj.orientation in info.frameOffsets))
		obj.orientation = 0 // ...
	var frameInfo = info.frameOffsets[obj.orientation][frameIdx]
	var dirOffset = info.directionOffsets[obj.orientation]
	var offsetX = Math.floor(frameInfo.w / 2) - dirOffset.x - frameInfo.ox
	var offsetY = frameInfo.h - dirOffset.y - frameInfo.oy

	return {x: scr.x - offsetX, y: scr.y - offsetY, w: frameInfo.w, h: frameInfo.h}
}

function drawObject(obj) {
	var scr = hexToScreen(obj.position.x, obj.position.y)

	if(images[obj.art] === undefined) {
		console.log("No art for object: " + obj.art + ", lazy loading...")
		lazyLoadImage(obj.art) // try to load it in
		return
	}

	var info = imageInfo[obj.art]
	if(info === undefined)
		throw "No image map info for: " + obj.art

	var frameIdx = 0
	if(obj.frame !== undefined)
		frameIdx += obj.frame

	if(!(obj.orientation in info.frameOffsets))
		obj.orientation = 0 // ...
	var frameInfo = info.frameOffsets[obj.orientation][frameIdx]
	var dirOffset = info.directionOffsets[obj.orientation]
	var offsetX = Math.floor(frameInfo.w / 2) - dirOffset.x - frameInfo.ox
	var offsetY = frameInfo.h - dirOffset.y - frameInfo.oy
	var scrX = scr.x - offsetX, scrY = scr.y - offsetY

	if(scrX + frameInfo.w < cameraX || scrY + frameInfo.h < cameraY ||
	   scrX >= cameraX+SCREEN_WIDTH || scrY >= cameraY+SCREEN_HEIGHT)
		return // out of screen bounds, no need to draw

	heart.ctx.drawImage(images[obj.art].img,
		frameInfo.sx, 0, frameInfo.w, frameInfo.h,
		scrX - cameraX,
		scrY - cameraY,
		frameInfo.w, frameInfo.h
	)
}

heart.draw = function() {
	if(isLoading === true) {
		heart.graphics.setColor(0, 0, 0)
		var w = 256, h = 40
		var w2 = (loadingAssetsLoaded / loadingAssetsTotal) * w
		// draw a loading progress bar
		heart.graphics.rectangle("stroke", SCREEN_WIDTH/2 - w/2, SCREEN_HEIGHT/2,
				w, h)
		heart.graphics.rectangle("fill", SCREEN_WIDTH/2 - w/2 + 2, SCREEN_HEIGHT/2 + 2,
				w2 - 4, h - 4)
		return
	}
	heart.graphics.setColor(255, 255, 255)

	var mousePos = heart.mouse.getPosition()
	var mouseHex = hexFromScreen(mousePos[0] + cameraX, mousePos[1] + cameraY)
	var mouseTile = tileFromScreen(mousePos[0] + cameraX, mousePos[1] + cameraY)

	// draw tile grids
	if(showFloor === true && floorMap !== null)
		drawTileMap(floorMap, 0);

	// draw hex grid overlay
	if(showHexOverlay === true || showCoordinates === true) {
		for(var y = 0; y < HEX_GRID_SIZE; y++) {
			for(var x = 0; x < HEX_GRID_SIZE; x++) {
				var scr = hexToScreen(x, y)
				heart.graphics.draw(hexOverlay, scr.x - 16 - cameraX, scr.y - 12 - cameraY)
				if(showCoordinates === true) {
					heart.graphics.print(x + "," + y, scr.x - 3 - cameraX, scr.y - 3 - cameraY)
				}
				if(showCoordinates === false && (x === mouseHex.x && y === mouseHex.y)) {
					heart.graphics.print("m", scr.x - 3 - cameraX, scr.y - 3 - cameraY)
				}
			}
		}
	} else {
		var scr = hexToScreen(mouseHex.x, mouseHex.y)
		heart.graphics.draw(hexOverlay, scr.x - 16 - cameraX, scr.y - 12 - cameraY)

		if(showPath === true && player.path !== null) {
			for(var i = 0; i < player.path.path.length; i++) {
				var scr = hexToScreen(player.path.path[i][0], player.path.path[i][1])
				heart.graphics.draw(hexOverlay, scr.x - 16 - cameraX, scr.y - 12 - cameraY)
			}
		} 
	}

	// draw objects and player
	if(showObjects === true) {
		for(var i = 0; i < gObjects.length; i++)
			if(gObjects[i].visible !== false && (gObjects[i].type !== "wall" || showWalls))
				drawObject(gObjects[i])
	}

	if(showRoof === true && roofMap !== null)
		drawTileMap(roofMap, -96);

	if(floorMap[mouseTile.y] !== undefined) {
		var tileImg = floorMap[mouseTile.y][mouseTile.x]
		heart.graphics.print("tile: " + tileImg, 5, 60)
	}

	if(inCombat === true) {
		var whose = combat.inPlayerTurn ? "player" : critterGetName(combat.combatants[combat.whoseTurn])
		var AP = combat.inPlayerTurn ? player.AP : combat.combatants[combat.whoseTurn].AP
		heart.graphics.print("[turn " + combat.turnNum + " of " + whose + " AP: " + AP.getAvailableMoveAP() + "]", SCREEN_WIDTH - 200, 15)
	}

	heart.graphics.print("mh: " + mouseHex.x + "," + mouseHex.y, 5, 15)
	heart.graphics.print("mt: " + mouseTile.x + "," + mouseTile.y, 100, 15)

	for(var i = 0; i < floatMessages.length; i++) {
		var bbox = objectBoundingBox(floatMessages[i].obj)
		if(bbox === null) continue
		heart.ctx.fillStyle = floatMessages[i].color
		var centerX = bbox.x - bbox.w/2 - cameraX
		heart.graphics.print(floatMessages[i].msg, centerX, bbox.y - cameraY - 16)
	}

	if(player.dead === true) {
		heart.graphics.setColor(255, 0, 0, 50)
		heart.graphics.rectangle("fill", 0, 0, SCREEN_WIDTH, SCREEN_HEIGHT)
	}
}

function dialogueReply(id) { scriptingEngine.dialogueReply(id) }
function dialogueEnd() { scriptingEngine.dialogueEnd() }

</script>
<style>
	body {
		font-family: sans-serif;
	}

	#dialogue {
		float: right;
		width: 30%;
		height: 60%;
		border: 1px solid black;
		visibility: hidden;
		overflow: auto;
	}

	#inventory {
		border: 1px solid black;
		width: 800px;
		height: 120px;
		margin-top: 2px;
	}

	.verticalInventory {
		border: 1px solid black;
		width: 120px;
		height: 600px;
		margin-top: 2px;
	}

	#barterLeft {
		float: left;
	}

	#barterLeft, #barterRight {
		visibility: hidden;
		display: inline-block;
		position: relative;
	}

	#rightArea {
		float: right;
		width: 45%;
	}

	#playerInventory {
		float: right;
	}
</style>
</head>
<body>

<canvas id="cnv" width="800" height="600">your browser doesn't support &lt;canvas&gt;</canvas>

<div id="rightArea">
	<div id="barterLeft" class="verticalInventory"></div>
	<div id="barterRight" class="verticalInventory"></div>

	<div id="playerInventory" class="verticalInventory"></div>

	<div id="dialogue"></div>
</div>
<div id="inventory"></div>


</body>
</html>